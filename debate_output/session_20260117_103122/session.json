{
  "initial_prompt": "Design a notification service with email and push notifications",
  "status": "debating",
  "rounds": 2,
  "started_at": "2026-01-17T10:31:22.318020",
  "ended_at": "2026-01-17T10:42:01.178417",
  "final_design": "## Design\n\n# Notification Service Architecture\n\n## System Overview\nA horizontally-scalable notification service supporting pluggable channels (email, push, SMS, etc.) with exactly-once delivery guarantees, hybrid queue architecture, and production-grade resilience patterns.\n\n## Architecture Components\n\n### 1. Core Service Layer\n\n**NotificationService (Orchestrator)**\n```typescript\ninterface NotificationService {\n  send(request: NotificationRequest): Promise<NotificationResult>;\n  sendBatch(requests: NotificationRequest[]): Promise<BatchResult>;\n  getStatus(notificationId: string): Promise<NotificationStatus>;\n  cancel(notificationId: string): Promise<void>;\n  retry(notificationId: string): Promise<NotificationResult>;\n}\n\ninterface BatchResult {\n  results: NotificationResult[];\n  summary: {\n    total: number;\n    succeeded: number;\n    failed: number;\n    pending: number;\n  };\n}\n```\n\n**Channel Provider (Strategy Pattern)**\n```typescript\ninterface ChannelProvider {\n  readonly type: ChannelType;\n  readonly capabilities: ProviderCapabilities;\n  \n  send(message: ChannelMessage): Promise<ProviderResult>;\n  validateRecipient(recipient: Recipient): ValidationResult;\n  healthCheck(): Promise<HealthStatus>;\n}\n\ninterface ProviderCapabilities {\n  batchSend: {\n    supported: boolean;\n    maxBatchSize?: number;\n  };\n  rateLimit: {\n    perSecond: number;\n    perMinute: number;\n    perHour?: number;\n  };\n  features: {\n    deliveryTracking: boolean;\n    scheduling: boolean;\n    richContent: boolean;\n  };\n}\n\ninterface ProviderResult {\n  success: boolean;\n  providerId: string;\n  providerMessageId?: string;\n  error?: ProviderError;\n  metadata?: Record<string, any>;\n}\n\n// Implementations\nclass SendGridEmailProvider implements ChannelProvider\nclass FCMPushProvider implements ChannelProvider\nclass TwilioSMSProvider implements ChannelProvider\n```\n\n### 2. Hybrid Queue Architecture\n\n**Queue Abstraction Layer**\n```typescript\ninterface QueueAdapter {\n  enqueue(message: QueueMessage, options: EnqueueOptions): Promise<string>;\n  dequeue(workerId: string, count: number): Promise<QueueMessage[]>;\n  ack(messageId: string, workerId: string): Promise<void>;\n  nack(messageId: string, workerId: string, reason: string): Promise<void>;\n  requeueWithDelay(messageId: string, delayMs: number): Promise<void>;\n  extendVisibility(messageId: string, workerId: string, durationMs: number): Promise<void>;\n  getDepth(priority?: NotificationPriority): Promise<number>;\n}\n\ninterface EnqueueOptions {\n  priority: NotificationPriority;\n  visibilityDelay: number; // For scheduled sends\n  deduplicationId?: string; // For exactly-once\n}\n\ninterface QueueMessage {\n  id: string;\n  notificationId: string;\n  payload: NotificationRequest;\n  priority: NotificationPriority;\n  enqueuedAt: Date;\n  visibleAt: Date;\n  dequeueCount: number;\n  workerId?: string;\n  leaseExpiry?: Date;\n}\n\n// Implementations for different scales\nclass PostgresQueueAdapter implements QueueAdapter // < 5K msg/sec\nclass RedisQueueAdapter implements QueueAdapter    // 5K-50K msg/sec\nclass SQSQueueAdapter implements QueueAdapter      // > 50K msg/sec\n```\n\n**PostgreSQL Queue (for low-to-medium scale)**\n```typescript\nclass PostgresQueueAdapter implements QueueAdapter {\n  async dequeue(workerId: string, count: number): Promise<QueueMessage[]> {\n    const leaseMs = 300000; // 5 minutes\n    \n    // Critical: Use advisory locks to prevent phantom reads\n    const result = await this.db.query(`\n      WITH selected AS (\n        SELECT id\n        FROM notification_queue\n        WHERE status = 'pending'\n          AND visible_at <= NOW()\n          AND (expires_at IS NULL OR expires_at > NOW())\n          AND pg_try_advisory_xact_lock(hashtext(id::text)) -- Prevents race conditions\n        ORDER BY \n          priority_order ASC,\n          visible_at ASC\n        LIMIT $1\n      )\n      UPDATE notification_queue nq\n      SET \n        status = 'processing',\n        worker_id = $2,\n        lease_expiry = NOW() + ($3 || ' milliseconds')::interval,\n        dequeue_count = dequeue_count + 1,\n        last_dequeued_at = NOW(),\n        version = version + 1\n      FROM selected\n      WHERE nq.id = selected.id\n      RETURNING nq.*\n    `, [count, workerId, leaseMs]);\n    \n    return result.rows.map(this.mapToQueueMessage);\n  }\n  \n  async ack(messageId: string, workerId: string): Promise<void> {\n    // Move to notifications table and delete from queue\n    const result = await this.db.query(`\n      WITH deleted AS (\n        DELETE FROM notification_queue\n        WHERE id = $1 \n          AND worker_id = $2\n          AND status = 'processing'\n        RETURNING *\n      )\n      UPDATE notifications\n      SET \n        status = 'sent',\n        sent_at = NOW(),\n        provider_response = deleted.provider_response,\n        processing_time_ms = EXTRACT(EPOCH FROM (NOW() - deleted.last_dequeued_at)) * 1000\n      FROM deleted\n      WHERE notifications.id = deleted.notification_id\n    `, [messageId, workerId]);\n    \n    if (result.rowCount === 0) {\n      throw new Error(`Cannot ack message ${messageId}: not owned by worker ${workerId}`);\n    }\n  }\n  \n  async nack(messageId: string, workerId: string, reason: string): Promise<void> {\n    // Release back to queue or move to DLQ\n    await this.db.query(`\n      UPDATE notification_queue\n      SET \n        status = CASE \n          WHEN dequeue_count >= max_attempts THEN 'failed'\n          ELSE 'pending'\n        END,\n        worker_id = NULL,\n        lease_expiry = NULL,\n        last_error = $3,\n        visible_at = CASE\n          WHEN dequeue_count >= max_attempts THEN visible_at\n          ELSE NOW() + (power(2, dequeue_count) * interval '1 second') -- Exponential backoff\n        END\n      WHERE id = $1 \n        AND worker_id = $2\n    `, [messageId, workerId, JSON.stringify({ reason, timestamp: new Date() })]);\n  }\n}\n```\n\n**Redis Queue (for high scale)**\n```typescript\nclass RedisQueueAdapter implements QueueAdapter {\n  // Use Redis Sorted Sets for priority queue\n  // Score = (priority_multiplier * 1e12) + timestamp_ms\n  \n  async enqueue(message: QueueMessage, options: EnqueueOptions): Promise<string> {\n    const priority = this.getPriorityMultiplier(options.priority);\n    const score = priority * 1e12 + options.visibilityDelay + Date.now();\n    \n    const pipeline = this.redis.pipeline();\n    \n    // Store message data\n    pipeline.hset(`msg:${message.id}`, {\n      payload: JSON.stringify(message.payload),\n      notificationId: message.notificationId,\n      enqueuedAt: message.enqueuedAt.toISOString(),\n      dequeueCount: 0,\n      maxAttempts: 5,\n    });\n    \n    // Add to sorted set\n    pipeline.zadd('notification_queue', score, message.id);\n    \n    // Deduplication\n    if (options.deduplicationId) {\n      pipeline.set(\n        `dedup:${options.deduplicationId}`,\n        message.id,\n        'EX',\n        3600, // 1 hour\n        'NX'\n      );\n    }\n    \n    await pipeline.exec();\n    return message.id;\n  }\n  \n  async dequeue(workerId: string, count: number): Promise<QueueMessage[]> {\n    const now = Date.now();\n    const leaseMs = 300000;\n    \n    // Lua script for atomic dequeue with lease\n    const script = `\n      local queue_key = KEYS[1]\n      local processing_key = KEYS[2]\n      local now = tonumber(ARGV[1])\n      local count = tonumber(ARGV[2])\n      local worker_id = ARGV[3]\n      local lease_ms = tonumber(ARGV[4])\n      \n      -- Get visible messages\n      local ids = redis.call('ZRANGEBYSCORE', queue_key, 0, now, 'LIMIT', 0, count)\n      \n      if #ids == 0 then\n        return {}\n      end\n      \n      local messages = {}\n      for _, id in ipairs(ids) do\n        -- Move to processing set\n        redis.call('ZREM', queue_key, id)\n        redis.call('ZADD', processing_key, now + lease_ms, id)\n        \n        -- Update message metadata\n        redis.call('HSET', 'msg:' .. id, \n          'workerId', worker_id,\n          'leaseExpiry', now + lease_ms,\n          'dequeueCount', redis.call('HINCRBY', 'msg:' .. id, 'dequeueCount', 1)\n        )\n        \n        -- Get full message\n        local msg = redis.call('HGETALL', 'msg:' .. id)\n        table.insert(messages, msg)\n      end\n      \n      return messages\n    `;\n    \n    const results = await this.redis.eval(\n      script,\n      2,\n      'notification_queue',\n      'processing_queue',\n      now,\n      count,\n      workerId,\n      leaseMs\n    );\n    \n    return this.parseRedisMessages(results);\n  }\n}\n```\n\n### 3. Worker Pool Architecture\n\n```typescript\nclass NotificationWorker {\n  private workerId: string;\n  private queue: QueueAdapter;\n  private providers: Map<ChannelType, ChannelProvider>;\n  private rateLimiters: Map<string, RateLimiter>;\n  private circuitBreakers: Map<string, CircuitBreaker>;\n  private running = false;\n  \n  constructor(\n    private config: WorkerConfig,\n    private db: Database\n  ) {\n    this.workerId = `${os.hostname()}-${process.pid}-${randomUUID()}`;\n    this.initializeQueue();\n    this.initializeProviders();\n  }\n  \n  async start(): Promise<void> {\n    this.running = true;\n    \n    // Start processing loop\n    this.processLoop();\n    \n    // Start heartbeat for worker health\n    this.heartbeatLoop();\n    \n    // Start lease extension for long-running tasks\n    this.leaseExtensionLoop();\n  }\n  \n  private async processLoop(): Promise<void> {\n    while (this.running) {\n      try {\n        const messages = await this.queue.dequeue(\n          this.workerId,\n          this.config.batchSize\n        );\n        \n        if (messages.length === 0) {\n          await this.sleep(this.config.pollIntervalMs);\n          continue;\n        }\n        \n        // Process in parallel with concurrency limit\n        await pMap(\n          messages,\n          (msg) => this.processMessage(msg),\n          { concurrency: this.config.concurrency }\n        );\n        \n      } catch (error) {\n        console.error('Worker process loop error:', error);\n        await this.sleep(5000);\n      }\n    }\n  }\n  \n  private async processMessage(message: QueueMessage): Promise<void> {\n    const startTime = Date.now();\n    let trackingSpan: Span | undefined;\n    \n    try {\n      // Start tracing span\n      trackingSpan = this.tracer.startSpan('process_notification', {\n        attributes: {\n          notificationId: message.notificationId,\n          channel: message.payload.channel,\n          priority: message.payload.priority,\n        }\n      });\n      \n      // Get provider\n      const provider = this.providers.get(message.payload.channel);\n      if (!provider) {\n        throw new NotificationError(\n          ErrorCategory.INTERNAL,\n          'NO_PROVIDER',\n          `No provider for channel ${message.payload.channel}`,\n          false\n        );\n      }\n      \n      // Check rate limits\n      const rateLimiter = this.rateLimiters.get(provider.type);\n      await rateLimiter.acquire();\n      \n      // Check circuit breaker\n      const circuitBreaker = this.circuitBreakers.get(provider.type);\n      \n      // Send with circuit breaker protection\n      const result = await circuitBreaker.execute(() =>\n        provider.send(this.buildChannelMessage(message.payload))\n      );\n      \n      // Update notification record\n      await this.db.query(`\n        UPDATE notifications\n        SET \n          provider_message_id = $1,\n          provider_response = $2\n        WHERE id = $3\n      `, [result.providerMessageId, result.metadata, message.notificationId]);\n      \n      // Acknowledge success\n      await this.queue.ack(message.id, this.workerId);\n      \n      // Fire webhook asynchronously (non-blocking)\n      if (message.payload.callbackUrl) {\n        this.fireWebhookAsync(message.payload.callbackUrl, {\n          notificationId: message.notificationId,\n          status: 'sent',\n          sentAt: new Date(),\n        }).catch(err => {\n          console.error('Webhook delivery failed:', err);\n          // Don't fail the notification - webhooks are best-effort\n        });\n      }\n      \n      // Record metrics\n      this.metrics.notificationsSent.inc({\n        channel: message.payload.channel,\n        priority: message.payload.priority,\n      });\n      \n      this.metrics.processingLatency.observe(\n        { channel: message.payload.channel },\n        Date.now() - startTime\n      );\n      \n    } catch (error) {\n      const notifError = this.normalizeError(error);\n      \n      // Record failure\n      await this.db.query(`\n        UPDATE notifications\n        SET \n          last_error = $1,\n          attempt_count = $2\n        WHERE id = $3\n      `, [\n        JSON.stringify(notifError),\n        message.dequeueCount,\n        message.notificationId\n      ]);\n      \n      // Determine retry strategy\n      const shouldRetry = this.shouldRetry(message.dequeueCount, notifError);\n      \n      if (shouldRetry) {\n        // Nack with retry\n        await this.queue.nack(message.id, this.workerId, notifError.message);\n        \n        this.metrics.notificationsRetried.inc({\n          channel: message.payload.channel,\n          errorCategory: notifError.category,\n        });\n      } else {\n        // Move to DLQ\n        await this.moveToDLQ(message, notifError);\n        await this.queue.ack(message.id, this.workerId); // Remove from queue\n        \n        this.metrics.notificationsFailed.inc({\n          channel: message.payload.channel,\n          errorCategory: notifError.category,\n        });\n      }\n      \n    } finally {\n      trackingSpan?.end();\n    }\n  }\n  \n  private async leaseExtensionLoop(): Promise<void> {\n    // Extend leases for messages taking longer than expected\n    while (this.running) {\n      await this.sleep(60000); // Every minute\n      \n      // Get all processing messages for this worker\n      const messages = await this.getProcessingMessages();\n      \n      for (const msg of messages) {\n        const timeLeft = msg.leaseExpiry.getTime() - Date.now();\n        \n        // Extend if less than 2 minutes remaining\n        if (timeLeft < 120000) {\n          await this.queue.extendVisibility(msg.id, this.workerId, 300000);\n        }\n      }\n    }\n  }\n  \n  private async heartbeatLoop(): Promise<void> {\n    // Update worker health status\n    while (this.running) {\n      await this.db.query(`\n        INSERT INTO worker_health (worker_id, last_heartbeat, processing_count)\n        VALUES ($1, NOW(), $2)\n        ON CONFLICT (worker_id) \n        DO UPDATE SET \n          last_heartbeat = NOW(),\n          processing_count = $2\n      `, [this.workerId, await this.getProcessingCount()]);\n      \n      await this.sleep(30000); // Every 30 seconds\n    }\n  }\n}\n```\n\n### 4. Data Models\n\n```typescript\nenum ChannelType {\n  EMAIL = 'email',\n  PUSH = 'push',\n  SMS = 'sms',\n  WEBHOOK = 'webhook'\n}\n\nenum NotificationPriority {\n  LOW = 0,\n  NORMAL = 1,\n  HIGH = 2,\n  URGENT = 3\n}\n\nenum NotificationStatus {\n  PENDING = 'pending',      // Created, not yet queued\n  QUEUED = 'queued',        // In queue\n  PROCESSING = 'processing', // Being processed\n  SENT = 'sent',            // Successfully sent to provider\n  DELIVERED = 'delivered',   // Confirmed delivered (if tracking available)\n  FAILED = 'failed',        // Permanently failed\n  CANCELLED = 'cancelled',   // User cancelled\n  EXPIRED = 'expired'       // Expired before sending\n}\n\ninterface NotificationRequest {\n  id?: string;\n  channel: ChannelType;\n  recipient: Recipient;\n  content: NotificationContent;\n  priority: NotificationPriority;\n  metadata?: Record<string, any>;\n  scheduledFor?: Date;\n  expiresAt?: Date;\n  idempotencyKey?: string;\n  callbackUrl?: string;\n  retryPolicy?: RetryPolicy;\n}\n\ninterface RetryPolicy {\n  maxAttempts: number;\n  backoffMultiplier: number;\n  maxBackoffMs: number;\n}\n\ninterface Recipient {\n  userId?: string;\n  email?: string;\n  phone?: string;\n  deviceTokens?: string[];\n  locale?: string;\n  timezone?: string;\n  metadata?: Record<string, any>;\n}\n\ninterface NotificationContent {\n  // Email fields\n  subject?: string;\n  htmlBody?: string;\n  textBody?: string;\n  \n  // Push fields\n  title?: string;\n  body: string;\n  imageUrl?: string;\n  clickAction?: string;\n  \n  // Common\n  templateId?: string;\n  variables?: Record<string, any>;\n  attachments?: Attachment[];\n}\n\ninterface NotificationResult {\n  notificationId: string;\n  status: NotificationStatus;\n  enqueuedAt: Date;\n  sentAt?: Date;\n  error?: NotificationError;\n  providerMessageId?: string;\n  estimatedDeliveryAt?: Date;\n}\n```\n\n### 5. Database Schema\n\n```sql\n-- Core notifications table (canonical record)\nCREATE TABLE notifications (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  channel VARCHAR(20) NOT NULL,\n  recipient JSONB NOT NULL,\n  content JSONB NOT NULL,\n  priority SMALLINT NOT NULL,\n  status VARCHAR(20) NOT NULL,\n  \n  idempotency_key VARCHAR(255),\n  callback_url TEXT,\n  metadata JSONB,\n  \n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  scheduled_for TIMESTAMPTZ,\n  expires_at TIMESTAMPTZ,\n  \n  sent_at TIMESTAMPTZ,\n  delivered_at TIMESTAMPTZ,\n  failed_at TIMESTAMPTZ,\n  \n  attempt_count INTEGER NOT NULL DEFAULT 0,\n  max_attempts INTEGER NOT NULL DEFAULT 5,\n  last_error JSONB,\n  \n  provider_message_id VARCHAR(255),\n  provider_response JSONB,\n  processing_time_ms INTEGER,\n  \n  CONSTRAINT uq_idempotency UNIQUE (idempotency_key)\n);\n\nCREATE INDEX idx_notifications_status ON notifications(status, created_at DESC);\nCREATE INDEX idx_notifications_scheduled ON notifications(scheduled_for) \n  WHERE status = 'pending' AND scheduled_for IS NOT NULL;\nCREATE INDEX idx_notifications_expires ON notifications(expires_at) \n  WHERE status IN ('pending', 'queued') AND expires_at IS NOT NULL;\n\n-- Separate queue table for high-throughput processing\nCREATE TABLE notification_queue (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  notification_id UUID NOT NULL REFERENCES notifications(id) ON DELETE CASCADE,\n  \n  status VARCHAR(20) NOT NULL DEFAULT 'pending',\n  priority_order INTEGER NOT NULL, -- Computed from priority for sorting\n  \n  visible_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  expires_at TIMESTAMPTZ,\n  \n  worker_id VARCHAR(255),\n  lease_expiry TIMESTAMPTZ,\n  \n  dequeue_count INTEGER NOT NULL DEFAULT 0,\n  max_attempts INTEGER NOT NULL DEFAULT 5,\n  last_error JSONB,\n  last_dequeued_at TIMESTAMPTZ,\n  \n  version INTEGER NOT NULL DEFAULT 0, -- Optimistic locking\n  \n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\n-- Critical index for dequeue performance\nCREATE INDEX idx_queue_processing ON notification_queue(\n  priority_order ASC,\n  visible_at ASC\n) WHERE status = 'pending';\n\n-- Index for stuck message cleanup\nCREATE INDEX idx_queue_stuck ON notification_queue(lease_expiry, worker_id)\n  WHERE status = 'processing' AND lease_expiry IS NOT NULL;\n\n-- Dead letter queue\nCREATE TABLE notification_dlq (\n  id UUID PRIMARY KEY,\n  notification_id UUID NOT NULL,\n  original_request JSONB NOT NULL,\n  final_error JSONB NOT NULL,\n  attempt_count INTEGER NOT NULL,\n  failed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  requeued_at TIMESTAMPTZ,\n  \n  INDEX idx_dlq_failed_at (failed_at DESC)\n);\n\n-- Worker health tracking\nCREATE TABLE worker_health (\n  worker_id VARCHAR(255) PRIMARY KEY,\n  last_heartbeat TIMESTAMPTZ NOT NULL,\n  processing_count INTEGER NOT NULL DEFAULT 0,\n  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  \n  INDEX idx_worker_heartbeat (last_heartbeat DESC)\n);\n\n-- Audit trail\nCREATE TABLE notification_events (\n  id BIGSERIAL PRIMARY KEY,\n  notification_id UUID NOT NULL REFERENCES notifications(id) ON DELETE CASCADE,\n  event_type VARCHAR(50) NOT NULL,\n  from_status VARCHAR(20),\n  to_status VARCHAR(20),\n  worker_id VARCHAR(255),\n  error JSONB,\n  metadata JSONB,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  \n  INDEX idx_events_notification (notification_id, created_at DESC),\n  INDEX idx_events_type (event_type, created_at DESC)\n);\n\n-- Provider rate limiting (distributed)\nCREATE TABLE provider_rate_limits (\n  provider_id VARCHAR(100) NOT NULL,\n  window_start TIMESTAMPTZ NOT NULL,\n  window_type VARCHAR(10) NOT NULL, -- 'second', 'minute', 'hour'\n  token_count INTEGER NOT NULL DEFAULT 0,\n  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  \n  PRIMARY KEY (provider_id, window_start, window_type)\n);\n\nCREATE INDEX idx_rate_limits_active ON provider_rate_limits(\n  provider_id, window_type, window_start DESC\n);\n\n-- Device token management\nCREATE TABLE device_tokens (\n  id BIGSERIAL PRIMARY KEY,\n  user_id VARCHAR(255) NOT NULL,\n  token VARCHAR(500) NOT NULL,\n  platform VARCHAR(20) NOT NULL,\n  is_active BOOLEAN NOT NULL DEFAULT true,\n  last_used_at TIMESTAMPTZ,\n  invalidated_at TIMESTAMPTZ,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  \n  CONSTRAINT uq_device_token UNIQUE (token),\n  INDEX idx_tokens_user_active (user_id, is_active) WHERE is_active = true\n);\n\n-- Template storage\nCREATE TABLE notification_templates (\n  id VARCHAR(100) NOT NULL,\n  channel VARCHAR(20) NOT NULL,\n  version INTEGER NOT NULL,\n  name VARCHAR(255) NOT NULL,\n  template_data JSONB NOT NULL,\n  is_active BOOLEAN NOT NULL DEFAULT true,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n  \n  PRIMARY KEY (id, version),\n  INDEX idx_templates_active (id, is_active, version DESC) WHERE is_active = true\n);\n```\n\n### 6. Resilience Patterns\n\n**Adaptive Circuit Breaker**\n```typescript\nclass CircuitBreaker {\n  private state: 'closed' | 'open' | 'half_open' = 'closed';\n  private failureCount = 0;\n  private successCount = 0;\n  private lastStateChange = Date.now();\n  private halfOpenRequestsAllowed = 1; // Start with 1 test request\n  private activeHalfOpenRequests = 0;\n  \n  constructor(\n    private readonly config: {\n      failureThreshold: number;\n      openDurationMs: number;\n      halfOpenSuccessThreshold: number;\n      halfOpenMaxConcurrent: number;\n    }\n  ) {}\n  \n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    // Check if should transition to half-open\n    if (this.state === 'open') {\n      const timeSinceOpen = Date.now() - this.lastStateChange;\n      if (timeSinceOpen >= this.config.openDurationMs) {\n        this.transitionToHalfOpen();\n      } else {\n        throw new CircuitOpenError(\n          `Circuit open, retry after ${this.config.openDurationMs - timeSinceOpen}ms`\n        );\n      }\n    }\n    \n    // Limit concurrent half-open requests\n    if (this.state === 'half_open') {\n      if (this.activeHalfOpenRequests >= this.halfOpenRequestsAllowed) {\n        throw new CircuitOpenError('Half-open circuit at capacity');\n      }\n      this.activeHalfOpenRequests++;\n    }\n    \n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure(error);\n      throw error;\n    } finally {\n      if (this.state === 'half_open') {\n        this.activeHalfOpenRequests--;\n      }\n    }\n  }\n  \n  private onSuccess(): void {\n    if (this.state === 'half_open') {\n      this.successCount++;\n      \n      if (this.successCount >= this.config.halfOpenSuccessThreshold) {\n        this.transitionToClosed();\n      } else {\n        // Gradually increase allowed concurrent requests\n        this.halfOpenRequestsAllowed = Math.min(\n          this.halfOpenRequestsAllowed + 1,\n          this.config.halfOpenMaxConcurrent\n        );\n      }\n    } else if (this.state === 'closed') {\n      this.failureCount = Math.max(0, this.failureCount - 1); // Decay failures\n    }\n  }\n  \n  private onFailure(error: any): void {\n    if (this.state === 'half_open') {\n      // Immediate reopen on any failure in half-open\n      this.transitionToOpen();\n    } else if (this.state === 'closed') {\n      this.failureCount++;\n      if (this.failureCount >= this.config.failureThreshold) {\n        this.transitionToOpen();\n      }\n    }\n  }\n  \n  private transitionToOpen(): void {\n    this.state = 'open';\n    this.lastStateChange = Date.now();\n    this.successCount = 0;\n    console.warn(`Circuit breaker opened after ${this.failureCount} failures`);\n  }\n  \n  private transitionToHalfOpen(): void {\n    this.state = 'half_open';\n    this.lastStateChange = Date.now();\n    this.successCount = 0;\n    this.halfOpenRequestsAllowed = 1;\n    this.activeHalfOpenRequests = 0;\n    console.info('Circuit breaker entering half-open state');\n  }\n  \n  private transitionToClosed(): void {\n    this.state = 'closed';\n    this.lastStateChange = Date.now();\n    this.failureCount = 0;\n    this.successCount = 0;\n    console.info('Circuit breaker closed after successful recovery');\n  }\n}\n```\n\n**Token Bucket Rate Limiter**\n```typescript\nclass DistributedRateLimiter {\n  constructor(\n    private db: Database,\n    private providerId: string,\n    private limits: {\n      perSecond: number;\n      perMinute: number;\n      perHour?: number;\n    }\n  ) {}\n  \n  async acquire(): Promise<void> {\n    const windows = [\n      { type: 'second', limit: this.limits.perSecond, durationMs: 1000 },\n      { type: 'minute', limit: this.limits.perMinute, durationMs: 60000 },\n    ];\n    \n    if (this.limits.perHour) {\n      windows.push({ type: 'hour', limit: this.limits.perHour, durationMs: 3600000 });\n    }\n    \n    for (const window of windows) {\n      const windowStart = new Date(\n        Math.floor(Date.now() / window.durationMs) * window.durationMs\n      );\n      \n      const result = await this.db.query(`\n        INSERT INTO provider_rate_limits (provider_id, window_start, window_type, token_count)\n        VALUES ($1, $2, $3, 1)\n        ON CONFLICT (provider_id, window_start, window_type)\n        DO UPDATE SET \n          token_count = provider_rate_limits.token_count + 1,\n          updated_at = NOW()\n        RETURNING token_count\n      `, [this.providerId, windowStart, window.type]);\n      \n      const currentCount = result.rows[0].token_count;\n      \n      if (currentCount > window.limit) {\n        const retryAfterMs = windowStart.getTime() + window.durationMs - Date.now();\n        \n        // Exponential backoff for rate limit\n        await this.sleep(Math.min(retryAfterMs, 5000));\n        \n        throw new RateLimitError(\n          `Rate limit exceeded for ${window.type} window`,\n          retryAfterMs\n        );\n      }\n    }\n  }\n  \n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n```\n\n**Retry Handler with Jitter**\n```typescript\nclass RetryHandler {\n  shouldRetry(attempt: number, error: NotificationError): boolean {\n    if (attempt >= 5) return false;\n    if (error.category === ErrorCategory.VALIDATION) return false;\n    if (error.category === ErrorCategory.PERMANENT) return false;\n    return error.retryable;\n  }\n  \n  calculateBackoff(attempt: number, error: NotificationError): number {\n    const baseMs = 1000;\n    const maxMs = 300000; // 5 minutes\n    \n    // Longer backoff for rate limits\n    const multiplier = error.category === ErrorCategory.RATE_LIMIT ? 3 : 1;\n    \n    // Exponential backoff: base * 2^attempt * multiplier\n    const exponential = baseMs * Math.pow(2, attempt) * multiplier;\n    \n    // Full jitter: random between 0 and exponential\n    const withJitter = Math.random() * exponential;\n    \n    return Math.min(withJitter, maxMs);\n  }\n}\n```\n\n### 7. Webhook Delivery System\n\n```typescript\nclass WebhookDeliveryService {\n  private webhookQueue: Queue; // Separate queue for webhooks\n  \n  async enqueueWebhook(webhook: WebhookPayload): Promise<void> {\n    // Non-blocking: fire and forget\n    await this.webhookQueue.enqueue({\n      url: webhook.url,\n      payload: webhook.payload,\n      maxAttempts: 3,\n      timeoutMs: 5000,\n    });\n  }\n  \n  async deliverWebhook(webhook: WebhookJob): Promise<void> {\n    try {\n      const response = await fetch(webhook.url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Notification-Event': webhook.payload.event,\n          'X-Notification-ID': webhook.payload.notificationId,\n          'X-Signature': this.signPayload(webhook.payload),\n        },\n        body: JSON.stringify(webhook.payload),\n        signal: AbortSignal.timeout(webhook.timeoutMs),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Webhook returned ${response.status}`);\n      }\n      \n      // Log success\n      await this.logWebhookDelivery(webhook, 'success');\n      \n    } catch (error) {\n      // Log failure but don't block notification\n      await this.logWebhookDelivery(webhook, 'failed', error);\n      \n      // Retry with backoff\n      if (webhook.attempt < webhook.maxAttempts) {\n        await this.webhookQueue.requeueWithDelay(\n          webhook.id,\n          this.calculateBackoff(webhook.attempt)\n        );\n      }\n    }\n  }\n  \n  private signPayload(payload: any): string {\n    // HMAC signature for webhook verification\n    return crypto\n      .createHmac('sha256', process.env.WEBHOOK_SECRET!)\n      .update(JSON.stringify(payload))\n      .digest('hex');\n  }\n}\n```\n\n### 8. Background Maintenance\n\n```typescript\nclass MaintenanceService {\n  async start(): Promise<void> {\n    // Release stuck messages (every 60s)\n    setInterval(() => this.releaseStuckMessages(), 60000);\n    \n    // Expire old notifications (every 5 min)\n    setInterval(() => this.expireNotifications(), 300000);\n    \n    // Cleanup dead workers (every 5 min)\n    setInterval(() => this.cleanupDeadWorkers(), 300000);\n    \n    // Archive old records (daily)\n    setInterval(() => this.archiveOldRecords(), 86400000);\n  }\n  \n  private async releaseStuckMessages(): Promise<void> {\n    // Messages with expired leases\n    await this.db.query(`\n      UPDATE notification_queue\n      SET \n        status = 'pending',\n        worker_id = NULL,\n        lease_expiry = NULL,\n        visible_at = NOW() + interval '30 seconds'\n      WHERE status = 'processing'\n        AND lease_expiry < NOW()\n    `);\n  }\n  \n  private async expireNotifications(): Promise<void> {\n    await this.db.transaction(async (tx) => {\n      // Mark as expired\n      await tx.query(`\n        UPDATE notifications\n        SET status = 'expired', updated_at = NOW()\n        WHERE status IN ('pending', 'queued')\n          AND expires_at <= NOW()\n      `);\n      \n      // Remove from queue\n      await tx.query(`\n        DELETE FROM notification_queue\n        WHERE notification_id IN (\n          SELECT id FROM notifications WHERE status = 'expired'\n        )\n      `);\n    });\n  }\n  \n  private async cleanupDeadWorkers(): Promise<void> {\n    const cutoff = new Date(Date.now() - 600000); // 10 min\n    \n    await this.db.query(`\n      DELETE FROM worker_health\n      WHERE last_heartbeat < $1\n    `, [cutoff]);\n  }\n  \n  private async archiveOldRecords(): Promise<void> {\n    const archiveThreshold = new Date(Date.now() - 90 * 86400000); // 90 days\n    \n    await this.db.transaction(async (tx) => {\n      // Archive to cold storage (S3, etc.)\n      const oldRecords = await tx.query(`\n        SELECT * FROM notifications\n        WHERE created_at < $1\n          AND status IN ('sent', 'delivered', 'failed', 'expired', 'cancelled')\n      `, [archiveThreshold]);\n      \n      if (oldRecords.rows.length > 0) {\n        await this.archiveToS3(oldRecords.rows);\n        \n        await tx.query(`\n          DELETE FROM notifications\n          WHERE created_at < $1\n            AND status IN ('sent', 'delivered', 'failed', 'expired', 'cancelled')\n        `, [archiveThreshold]);\n      }\n    });\n  }\n}\n```\n\n### 9. Monitoring & Observability\n\n```typescript\ninterface NotificationMetrics {\n  // Counters\n  notificationsSent: Counter<{ channel: string; priority: string }>;\n  notificationsFailed: Counter<{ channel: string; errorCategory: string }>;\n  notificationsRetried: Counter<{ channel: string; attempt: number }>;\n  webhooksDelivered: Counter<{ success: boolean }>;\n  \n  // Gauges\n  queueDepth: Gauge<{ priority: string }>;\n  activeWorkers: Gauge;\n  circuitBreakerState: Gauge<{ provider: string }>; // 0=closed, 1=half-open, 2=open\n  oldestQueuedMessage: Gauge; // Age in seconds\n  \n  // Histograms\n  processingLatency: Histogram<{ channel: string }>; // End-to-end processing time\n  providerLatency: Histogram<{ provider: string }>; // Provider API call time\n  queueWaitTime: Histogram<{ priority: string }>; // Time in queue before processing\n  \n  // Business metrics\n  deliveryRate: Gauge<{ channel: string }>; // Success rate over time window\n  costPerNotification: Histogram<{ channel: string }>;\n}\n\n// Health check endpoint\napp.get('/health', async (req, res) => {\n  const checks = await Promise.all([\n    checkDatabase(),\n    checkQueue(),\n    checkProviders(),\n  ]);\n  \n  const healthy = checks.every(c => c.healthy);\n  \n  res.status(healthy ? 200 : 503).json({\n    status: healthy ? 'healthy' : 'unhealthy',\n    checks,\n    uptime: process.uptime(),\n    memory: process.memoryUsage(),\n  });\n});\n\n// Metrics endpoint (Prometheus format)\napp.get('/metrics', async (req, res) => {\n  res.set('Content-Type', register.contentType);\n  res.send(await register.metrics());\n});\n```"
}