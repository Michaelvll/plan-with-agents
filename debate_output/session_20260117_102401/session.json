{
  "initial_prompt": "Design a webhook delivery system with retries",
  "status": "consensus",
  "rounds": 2,
  "started_at": "2026-01-17T10:24:01.222215",
  "ended_at": "2026-01-17T10:31:21.450356",
  "final_design": "## Design\n\n# Webhook Delivery System with Retries\n\n## System Architecture\n\n### Components\n\n1. **Webhook API Service**\n   - Accepts webhook registration requests with URL validation\n   - Validates webhook configurations\n   - Stores webhook subscriptions in database\n   - Provides CRUD operations for webhooks\n   - Enforces per-tenant quotas and rate limits\n\n2. **Event Publisher**\n   - Receives events from application components\n   - Validates event payloads against schema\n   - Performs duplicate detection using idempotency keys\n   - Publishes events to message queue for async processing\n   - Returns immediately to avoid blocking event sources\n\n3. **Delivery Worker Pool**\n   - Consumes events from message queue with priority handling\n   - Checks circuit breaker and rate limiter before delivery\n   - Executes HTTP POST requests to registered webhook URLs\n   - Implements retry logic with exponential backoff\n   - Records delivery attempts and outcomes with detailed error classification\n   - Updates circuit breaker metrics based on error patterns\n   - Handles graceful degradation for partial failures\n\n4. **Dead Letter Queue (DLQ) Handler**\n   - Processes events that exhausted all retry attempts\n   - Classifies failures by type (permanent vs potentially recoverable)\n   - Logs failed deliveries for manual inspection\n   - Provides API for retry of failed deliveries with bulk operations\n   - Alerts webhook owners of permanent failures via email/notification\n   - Supports scheduled batch retry for DLQ items with rate limiting\n\n5. **Circuit Breaker Manager**\n   - Maintains per-webhook circuit state with error pattern analysis\n   - Uses time-window based thresholds (failure rate over period)\n   - Gradual recovery mechanism with probe requests\n   - Prevents cascade failures across tenant boundaries\n\n6. **Monitoring & Observability**\n   - Tracks delivery success/failure rates by error type\n   - Monitors queue depths and worker health\n   - Exposes metrics for latency and throughput by percentile\n   - Provides webhook delivery history API with filtering\n   - Tracks circuit breaker state transitions\n   - Alert on anomalous failure patterns\n\n### Technology Stack\n\n- **Message Queue**: RabbitMQ with priority queues and DLQ support\n- **Database**: PostgreSQL (for webhook configs and delivery logs)\n- **Cache Layer**: Redis (for circuit breaker state, rate limiting, deduplication)\n- **Worker Framework**: Custom Go workers with concurrency control\n- **API Framework**: FastAPI (Python) with async support\n\n## Data Models\n\n### Webhook Subscription\n```json\n{\n  \"id\": \"uuid\",\n  \"owner_id\": \"string\",\n  \"tenant_id\": \"string\",\n  \"url\": \"https://customer.example.com/webhook\",\n  \"events\": [\"user.created\", \"order.completed\"],\n  \"secret\": \"signing_secret_for_hmac\",\n  \"active\": true,\n  \"retry_config\": {\n    \"max_attempts\": 5,\n    \"base_delay_ms\": 1000,\n    \"max_delay_ms\": 300000,\n    \"backoff_multiplier\": 2.0,\n    \"timeout_ms\": 30000,\n    \"timeout_growth_factor\": 1.0\n  },\n  \"circuit_breaker_config\": {\n    \"enabled\": true,\n    \"error_threshold_percentage\": 50,\n    \"minimum_throughput\": 10,\n    \"window_size_ms\": 60000,\n    \"sleep_window_ms\": 30000,\n    \"half_open_max_calls\": 3,\n    \"force_open_until\": null\n  },\n  \"rate_limit\": {\n    \"requests_per_minute\": 100,\n    \"burst\": 20\n  },\n  \"ordering_guarantee\": \"none\",\n  \"headers\": {\n    \"X-Custom-Header\": \"value\"\n  },\n  \"created_at\": \"timestamp\",\n  \"updated_at\": \"timestamp\",\n  \"last_success_at\": \"timestamp\",\n  \"metadata\": {}\n}\n```\n\n### Delivery Attempt\n```json\n{\n  \"id\": \"uuid\",\n  \"webhook_id\": \"uuid\",\n  \"event_id\": \"uuid\",\n  \"attempt_number\": 1,\n  \"status\": \"pending|success|failed|exhausted|circuit_blocked\",\n  \"failure_category\": \"timeout|server_error|client_error|network|dns|ssl|rate_limit|payload_too_large\",\n  \"http_status_code\": 200,\n  \"response_body_sample\": \"limited to 1KB\",\n  \"error_message\": \"string\",\n  \"duration_ms\": 245,\n  \"scheduled_at\": \"timestamp\",\n  \"executed_at\": \"timestamp\",\n  \"next_retry_at\": \"timestamp\",\n  \"circuit_breaker_prevented\": false\n}\n```\n\n### Event Payload\n```json\n{\n  \"id\": \"uuid\",\n  \"event_type\": \"user.created\",\n  \"data\": {\n    \"user_id\": 12345,\n    \"email\": \"user@example.com\"\n  },\n  \"timestamp\": \"ISO8601\",\n  \"idempotency_key\": \"unique_per_event\",\n  \"source\": \"api-service\",\n  \"priority\": \"high|normal|low\",\n  \"sequence_number\": 12345\n}\n```\n\n### Circuit Breaker State\n```json\n{\n  \"webhook_id\": \"uuid\",\n  \"state\": \"closed|open|half_open\",\n  \"failure_count_in_window\": 8,\n  \"success_count_in_window\": 2,\n  \"total_calls_in_window\": 10,\n  \"error_percentage\": 80.0,\n  \"window_start\": \"timestamp\",\n  \"state_transition_at\": \"timestamp\",\n  \"next_half_open_at\": \"timestamp\",\n  \"half_open_attempts\": 0,\n  \"half_open_successes\": 0\n}\n```\n\n## Interfaces\n\n### Webhook Registration API\n\n```\nPOST /v1/webhooks\n{\n  \"url\": \"https://...\",\n  \"events\": [\"event.type\"],\n  \"secret\": \"optional\",\n  \"retry_config\": {},\n  \"circuit_breaker_config\": {},\n  \"ordering_guarantee\": \"none|per_event_type|strict\",\n  \"verify_url\": true\n}\nResponse: 201 Created + webhook object\n\nGET /v1/webhooks\nQuery params: ?active=true&event_type=user.created&tenant_id=xyz\nResponse: 200 OK + list of webhooks\n\nGET /v1/webhooks/{id}\nResponse: 200 OK + webhook object\n\nGET /v1/webhooks/{id}/health\nResponse: 200 OK + circuit breaker state, recent delivery stats, error distribution\n\nPUT /v1/webhooks/{id}\nBody: partial webhook update\nResponse: 200 OK + updated webhook\n\nPATCH /v1/webhooks/{id}/circuit-breaker\nBody: {\"action\": \"reset|force_open|force_close\", \"duration_seconds\": 3600}\nResponse: 200 OK + updated circuit state\n\nDELETE /v1/webhooks/{id}\nResponse: 204 No Content\n```\n\n### Delivery History API\n\n```\nGET /v1/webhooks/{id}/deliveries?limit=50&offset=0&status=failed&from=2024-01-01\nResponse: paginated delivery attempts with filtering\n\nGET /v1/deliveries/{delivery_id}\nResponse: 200 OK + full delivery attempt details\n\nPOST /v1/webhooks/{id}/deliveries/{delivery_id}/retry\nBody: {\"priority\": \"high\"}\nResponse: 202 Accepted + new delivery_id\n\nPOST /v1/dlq/retry-batch\nBody: {\n  \"filter\": {\n    \"webhook_ids\": [\"id1\", \"id2\"],\n    \"event_types\": [\"user.created\"],\n    \"failure_categories\": [\"timeout\"]\n  },\n  \"rate_limit\": {\"requests_per_second\": 10},\n  \"priority\": \"normal\"\n}\nResponse: 202 Accepted + batch_operation_id\n\nGET /v1/dlq/batch-operations/{id}\nResponse: 200 OK + batch operation status and progress\n```\n\n### Event Publishing (Internal)\n\n```python\ndef publish_event(\n    event_type: str, \n    data: dict, \n    source: str,\n    idempotency_key: Optional[str] = None,\n    priority: str = \"normal\",\n    tenant_id: str = None\n) -> str:\n    \"\"\"\n    Publishes event to message queue for webhook delivery\n    Deduplicates based on idempotency_key if provided\n    Returns: event_id\n    Raises: \n      - DuplicateEventError if idempotency key seen within 24h\n      - PayloadTooLargeError if payload exceeds 256KB\n    \"\"\"\n```\n\n## Retry Logic\n\n### Simplified Exponential Backoff\n\n```python\ndef calculate_next_retry(\n    attempt: int, \n    config: RetryConfig,\n    failure_category: str\n) -> tuple[datetime, int]:\n    \"\"\"\n    Returns: (next_retry_timestamp, timeout_ms)\n    \n    Simpler approach: use consistent backoff with category-based minimum delays\n    Let circuit breaker handle broader failure patterns\n    \"\"\"\n    # Base exponential backoff\n    delay_ms = min(\n        config.base_delay_ms * (config.backoff_multiplier ** attempt),\n        config.max_delay_ms\n    )\n    \n    # Category-specific minimum delays only\n    category_minimums = {\n        \"rate_limit\": 60000,  # 1 minute minimum\n        \"dns\": 5000,          # 5 seconds (DNS might be propagating)\n        \"timeout\": 2000,      # 2 seconds (give server breathing room)\n    }\n    \n    if failure_category in category_minimums:\n        delay_ms = max(delay_ms, category_minimums[failure_category])\n    \n    # Simple uniform jitter (\u00b125%)\n    jitter = random.uniform(-0.25, 0.25) * delay_ms\n    final_delay_ms = max(0, delay_ms + jitter)\n    \n    # Timeout growth for subsequent attempts\n    timeout_ms = config.timeout_ms * (config.timeout_growth_factor ** attempt)\n    timeout_ms = min(timeout_ms, config.timeout_ms * 3)  # Cap at 3x\n    \n    return (now() + timedelta(milliseconds=final_delay_ms), int(timeout_ms))\n```\n\n### Retry Eligibility\n\n```python\nclass RetryDecision:\n    # Non-retryable HTTP status codes\n    PERMANENT_FAILURES = {400, 401, 403, 404, 410, 413, 414, 415, 451}\n    \n    def should_retry(\n        self, \n        attempt: int, \n        error_type: str,\n        http_status: Optional[int],\n        max_attempts: int\n    ) -> tuple[bool, str]:\n        \"\"\"\n        Returns: (should_retry, reason)\n        \"\"\"\n        if attempt >= max_attempts:\n            return (False, \"max_attempts_exceeded\")\n        \n        # Network/DNS errors - always retry\n        if error_type in [\"dns_failure\", \"connection_refused\", \"connection_timeout\", \"network_unreachable\"]:\n            return (True, f\"retryable_network_{error_type}\")\n        \n        # SSL errors - retry with limit\n        if error_type == \"ssl_error\":\n            return (attempt < 3, \"ssl_error_retry_limit\" if attempt >= 3 else \"ssl_error\")\n        \n        # HTTP status code based decisions\n        if http_status:\n            if http_status in self.PERMANENT_FAILURES:\n                return (False, f\"permanent_client_error_{http_status}\")\n            \n            if http_status == 429:\n                return (True, \"rate_limited\")\n            \n            if http_status >= 500:\n                return (True, f\"server_error_{http_status}\")\n            \n            if 200 <= http_status < 300:\n                return (False, \"success\")\n        \n        # Timeout errors\n        if error_type in [\"read_timeout\", \"request_timeout\"]:\n            return (True, \"timeout\")\n        \n        # Unknown - retry cautiously\n        return (True, \"unknown_error\")\n```\n\n## Circuit Breaker Design\n\n### Time-Window Based Circuit Breaker\n\n```python\nclass TimeWindowCircuitBreaker:\n    \"\"\"\n    Simpler, more predictable circuit breaker using rolling time windows\n    Avoids complexity of separate counters for different error types\n    \"\"\"\n    \n    def __init__(self, webhook_id: str, config: CircuitBreakerConfig):\n        self.webhook_id = webhook_id\n        self.config = config\n        self.state = \"closed\"\n        \n        # Rolling window data stored in Redis sorted set\n        # Key: webhook_id, Score: timestamp, Value: success|failure\n        self.window_key = f\"cb:{webhook_id}:window\"\n        \n    def record_attempt(self, success: bool, failure_category: Optional[str] = None):\n        \"\"\"\n        Records attempt in time window and evaluates state transition\n        \"\"\"\n        timestamp = now_ms()\n        result = \"success\" if success else f\"failure:{failure_category}\"\n        \n        # Add to sorted set with timestamp as score\n        redis.zadd(self.window_key, {result: timestamp})\n        \n        # Remove entries outside window\n        window_start = timestamp - self.config.window_size_ms\n        redis.zremrangebyscore(self.window_key, 0, window_start)\n        \n        # Update state based on current window\n        self._evaluate_state()\n    \n    def _evaluate_state(self):\n        \"\"\"\n        Evaluate state transition based on time window metrics\n        \"\"\"\n        timestamp = now_ms()\n        window_start = timestamp - self.config.window_size_ms\n        \n        # Get all attempts in window\n        attempts = redis.zrangebyscore(self.window_key, window_start, timestamp)\n        total = len(attempts)\n        failures = sum(1 for a in attempts if a.startswith(\"failure:\"))\n        \n        if self.state == \"closed\":\n            # Check if we should open\n            if total >= self.config.minimum_throughput:\n                error_rate = (failures / total) * 100\n                if error_rate >= self.config.error_threshold_percentage:\n                    self._transition_to_open()\n        \n        elif self.state == \"open\":\n            # Check if sleep window expired\n            state_age_ms = timestamp - self.state_transition_at\n            if state_age_ms >= self.config.sleep_window_ms:\n                self._transition_to_half_open()\n        \n        elif self.state == \"half_open\":\n            # Evaluate based on probe attempts\n            if self.half_open_attempts >= self.config.half_open_max_calls:\n                # Decision time\n                success_rate = self.half_open_successes / self.half_open_attempts\n                if success_rate >= 0.5:  # 50% threshold\n                    self._transition_to_closed()\n                else:\n                    self._transition_to_open()\n    \n    def should_allow_request(self) -> tuple[bool, str]:\n        \"\"\"\n        Returns: (allow, reason)\n        \"\"\"\n        # Check force_open override\n        if self.config.force_open_until and now() < self.config.force_open_until:\n            return (False, \"manually_forced_open\")\n        \n        if self.state == \"closed\":\n            return (True, \"circuit_closed\")\n        \n        if self.state == \"open\":\n            # Re-evaluate in case sleep window expired\n            self._evaluate_state()\n            if self.state == \"half_open\":\n                return self._allow_half_open_request()\n            return (False, \"circuit_open\")\n        \n        if self.state == \"half_open\":\n            return self._allow_half_open_request()\n    \n    def _allow_half_open_request(self) -> tuple[bool, str]:\n        \"\"\"\n        Rate-limit probe requests in half-open state\n        \"\"\"\n        if self.half_open_attempts < self.config.half_open_max_calls:\n            self.half_open_attempts += 1\n            return (True, \"circuit_half_open_probe\")\n        return (False, \"half_open_probe_limit_reached\")\n    \n    def _transition_to_open(self):\n        self.state = \"open\"\n        self.state_transition_at = now_ms()\n        self.half_open_attempts = 0\n        self.half_open_successes = 0\n        emit_metric(\"circuit_breaker_opened\", {\"webhook_id\": self.webhook_id})\n        notify_webhook_owner(self.webhook_id, \"circuit_opened\")\n    \n    def _transition_to_half_open(self):\n        self.state = \"half_open\"\n        self.state_transition_at = now_ms()\n        self.half_open_attempts = 0\n        self.half_open_successes = 0\n        emit_metric(\"circuit_breaker_half_opened\", {\"webhook_id\": self.webhook_id})\n    \n    def _transition_to_closed(self):\n        self.state = \"closed\"\n        self.state_transition_at = now_ms()\n        # Clear window on successful recovery\n        redis.delete(self.window_key)\n        emit_metric(\"circuit_breaker_closed\", {\"webhook_id\": self.webhook_id})\n        notify_webhook_owner(self.webhook_id, \"circuit_recovered\")\n```\n\n### Circuit Breaker and Retry Interaction\n\n```\nEvent Lifecycle with Circuit Breaker:\n\n1. Event arrives for webhook\n2. Check circuit breaker state:\n   \n   CLOSED:\n   - Attempt delivery normally\n   - If fails: record in circuit breaker, schedule retry\n   - Retry attempts proceed independently\n   \n   OPEN:\n   - Do NOT attempt delivery\n   - Record attempt as \"circuit_blocked\" (doesn't count toward retry limit)\n   - Requeue message with delay = min(circuit sleep window, max backoff delay)\n   - When circuit transitions to half-open, message will be reprocessed\n   \n   HALF_OPEN:\n   - Allow up to N probe requests\n   - If selected as probe: attempt delivery normally\n   - If not selected: treat as OPEN (requeue)\n\n3. Retry sequence behavior:\n   - Retry counter persists across circuit breaker cycles\n   - Example: Attempt 1 fails \u2192 circuit opens \u2192 retry 2 scheduled\n   - When circuit reopens: retry 2 proceeds (still counts as attempt 2)\n   - This prevents infinite retries due to circuit breaker delays\n```\n\n## Security\n\n1. **HMAC Signing**\n   - Sign payload with webhook secret using HMAC-SHA256\n   - Include timestamp in signature to prevent replay attacks (valid 5 minutes)\n   - Signature format: `t={timestamp},v1={signature}`\n   - Header: `X-Webhook-Signature: t=1234567890,v1={hmac_sha256}`\n\n2. **Request Headers**\n```\nPOST /webhook HTTP/1.1\nContent-Type: application/json\nX-Webhook-ID: {webhook_id}\nX-Webhook-Signature: t=1234567890,v1={hmac_sha256}\nX-Webhook-Event: user.created\nX-Webhook-Delivery: {delivery_id}\nX-Webhook-Attempt: 2\nX-Webhook-Timestamp: 2024-01-15T10:30:00Z\nX-Idempotency-Key: {event_idempotency_key}\nUser-Agent: WebhookService/1.0\n```\n\n3. **Timeout & Rate Limiting**\n   - HTTP request timeout: 30s default, grows by `timeout_growth_factor` per retry\n   - Per-webhook rate limit: configurable requests/minute with token bucket\n   - Per-tenant global rate limits (default: 1000 req/min)\n   - Connection pooling with max 5 concurrent connections per webhook\n\n4. **URL Validation**\n   - Block private IP ranges (RFC1918, loopback, link-local)\n   - Require HTTPS in production\n   - Optional verification request during registration (webhook must echo challenge)\n   - Max URL length: 2048 characters\n\n### Idempotency\n\n- Each event has unique `idempotency_key` (UUID v4 if not provided)\n- Included in delivery headers for consumer deduplication\n- Publisher deduplicates events within 24h window (Redis cache)\n- Retry attempts preserve same idempotency key\n- Consumers responsible for deduplication handling\n\n## Worker Processing Flow\n\n```\n1. Worker polls message queue with priority\n2. Extract webhook_id, event_id, attempt_number from message\n3. Load webhook config (cached in Redis, TTL 5min)\n4. Verify webhook is active:\n   - If inactive: ACK message, log skip, exit\n5. Check circuit breaker:\n   a. Load circuit state from Redis\n   b. Call should_allow_request()\n   c. If blocked:\n      - Record delivery attempt as \"circuit_blocked\"\n      - Calculate requeue delay = min(circuit sleep window remaining, max retry delay)\n      - NACK message with delay\n      - Exit\n   d. If allowed: proceed\n6. Check rate limiter (token bucket in Redis):\n   - If rate limited: NACK with 1s delay, exit\n7. Evaluate retry eligibility:\n   - If attempt >= max_attempts: move to DLQ, ACK, exit\n8. Build HTTP request:\n   a. Generate HMAC signature with timestamp\n   b. Add all standard headers\n   c. Calculate timeout based on attempt number\n9. Execute HTTP request with error capture:\n   a. Record start time\n   b. Execute POST with timeout\n   c. Record duration, status, response sample\n   d. Classify outcome and failure category\n10. Process outcome:\n    a. Success (2xx):\n       - Record in circuit breaker as success\n       - Store delivery attempt as \"success\"\n       - ACK message\n       - Exit\n    b. Retryable failure:\n       - Record in circuit breaker as failure\n       - Determine failure category\n       - Calculate next retry time and timeout\n       - Store delivery attempt as \"failed\"\n       - NACK message with retry delay\n       - Exit\n    c. Non-retryable failure:\n       - Record in circuit breaker as failure\n       - Store delivery attempt as \"exhausted\"\n       - Move to DLQ with classification\n       - ACK message\n       - Exit\n11. Handle worker errors:\n    - Redis/DB unavailable: NACK immediately (no delay)\n    - Unexpected exception: log, NACK, alert\n    - Graceful shutdown: NACK all in-flight\n```\n\n## Event Ordering\n\nThree ordering modes (webhook configuration):\n\n1. **none** (default): Maximum throughput, no ordering guarantees\n   - Events processed by any available worker\n   - Fastest option for most use cases\n\n2. **per_event_type**: Events of same type processed in order\n   - Use message queue partition key = `{webhook_id}:{event_type}`\n   - Events with different types can process in parallel\n   - Good balance for most ordering needs\n\n3. **strict**: All events for webhook processed sequentially\n   - Use message queue partition key = `{webhook_id}`\n   - Significant throughput impact\n   - Only use when strictly necessary\n\n## Payload Size Limits\n\n- Maximum event payload: 256KB (configurable)\n- Oversized payloads: rejected at publish time with clear error\n- Response body sample stored: max 1KB\n- Future enhancement: external blob storage for large payloads with reference URL\n\n## Failure Mode Handling\n\n**Database Unavailable:**\n- Cannot load webhook config \u2192 NACK immediately\n- Message returns to queue for retry\n- Alert after 5 consecutive DB failures\n\n**Redis Unavailable:**\n- Circuit breaker falls back to \"closed\" (fail-safe)\n- Rate limiting disabled temporarily\n- Worker logs warning and continues\n- Alert on Redis connection issues\n\n**Message Queue Connection Lost:**\n- Worker enters reconnection loop (exp backoff, max 5min)\n- In-flight messages auto-NACK on connection loss\n- Alert after 3 failed reconnection attempts\n\n**DNS Resolution Failure:**\n- Treat as retryable network error\n- Cache successful DNS lookups (TTL 5min)\n- If DNS fails consistently (>80% over 10min) \u2192 notify webhook owner\n\n**Worker Crash During Delivery:**\n- Message not ACKed \u2192 returns to queue\n- Other worker will retry\n- Duplicate delivery attempt records prevented by unique constraint on (event_id, webhook_id, attempt_number)\n\n**Webhook Returns 2xx After Long Processing:**\n- System treats as success\n- Consumer responsible for async processing patterns\n- Document best practices: return 2xx quickly, process async\n\n## Scalability Considerations\n\n- **Horizontal scaling**: Stateless workers, scale based on queue depth\n- **Tenant isolation**: Route high-volume tenants to dedicated worker pools via queue routing\n- **Priority queues**: Separate queues for high/normal/low priority\n- **Database partitioning**: \n  - Partition `delivery_attempts` by month\n  - Index on (webhook_id, executed_at) for history queries\n  - Archive to cold storage after 90 days\n- **Connection pooling**: Per-worker HTTP client with max 100 connections, max 5 per host\n- **Batch DLQ retry**: Rate-limited bulk retry (configurable req/sec)\n\n## Monitoring Metrics\n\n- `webhook_deliveries_total{status, event_type, failure_category, tenant_id}`\n- `webhook_delivery_duration_seconds{percentile}` (p50, p95, p99)\n- `webhook_retry_attempt_number{outcome}` (histogram)\n- `webhook_queue_depth{priority}`\n- `webhook_circuit_breaker_state{webhook_id, state}` (gauge)\n- `webhook_circuit_breaker_transitions_total{from_state, to_state}`\n- `webhook_dlq_size{tenant_id}`\n- `webhook_rate_limit_hits_total{webhook_id}`\n- `webhook_worker_pool_utilization{pool_id}`\n\n## Alerting Rules\n\n- Circuit breaker opened (severity: warning)\n- Circuit breaker open >1 hour (severity: critical)\n- DLQ size >1000 per tenant (severity: warning)\n- Webhook success rate <90% over 5min (severity: warning)\n- Worker pool >80% utilization (severity: warning)\n- Queue depth >10000 (severity: critical)"
}