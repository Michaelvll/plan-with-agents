{
  "initial_prompt": "Design a WebSocket notification service",
  "status": "debating",
  "rounds": 2,
  "started_at": "2026-01-17T08:51:54.377690",
  "ended_at": "2026-01-17T09:01:44.732625",
  "final_design": "## Design\n\n# WebSocket Notification Service\n\n## Architecture Overview\n\nA horizontally scalable, stateful WebSocket notification service with strong delivery guarantees, comprehensive failure recovery, and production-grade observability.\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Load Balancer (Layer 4 / Layer 7)              \u2502\n\u2502          Consistent Hash on user_id with fallback           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502                        \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 WS Server 1 \u2502          \u2502 WS Server 2 \u2502\n\u2502 (Node.js)   \u2502          \u2502 (Node.js)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                        \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502   Redis Cluster         \u2502\n       \u2502   - PubSub channels     \u2502\n       \u2502   - Connection registry \u2502\n       \u2502   - Sequence numbers    \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502   PostgreSQL            \u2502\n       \u2502   - Notification store  \u2502\n       \u2502   - Delivery tracking   \u2502\n       \u2502   - User preferences    \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n## Core Components\n\n### 1. WebSocket Server\n\n```typescript\n// server.ts\nimport WebSocket from 'ws';\nimport { createServer } from 'http';\nimport { RedisClient } from './redis-client';\nimport { NotificationStore } from './notification-store';\nimport { AuthService } from './auth-service';\nimport { RateLimiter } from './rate-limiter';\nimport { MetricsCollector } from './metrics';\n\ninterface ServerConfig {\n  port: number;\n  redisUrl: string;\n  postgresUrl: string;\n  heartbeatInterval: number;\n  maxConnectionsPerUser: number;\n  maxMessageSize: number;\n  messageRateLimit: number;\n  gracefulShutdownTimeout: number;\n  enableMessageOrdering: boolean; // NEW: configurable ordering\n  offlineRetentionDays: number; // NEW: how long to keep offline notifications\n}\n\nclass NotificationServer {\n  private wss: WebSocket.Server;\n  private redis: RedisClient;\n  private store: NotificationStore;\n  private auth: AuthService;\n  private rateLimiter: RateLimiter;\n  private metrics: MetricsCollector;\n  private connections: Map<string, Set<WebSocket>>;\n  private isShuttingDown: boolean = false;\n  private config: ServerConfig;\n  private serverId: string;\n  private messageOrdering: MessageOrderingService | null;\n\n  constructor(config: ServerConfig) {\n    this.config = config;\n    this.serverId = `${process.env.HOSTNAME || 'server'}-${process.pid}`;\n    this.connections = new Map();\n    this.redis = new RedisClient(config.redisUrl);\n    this.store = new NotificationStore(config.postgresUrl);\n    this.auth = new AuthService();\n    this.rateLimiter = new RateLimiter(config.messageRateLimit);\n    this.metrics = new MetricsCollector();\n    this.messageOrdering = config.enableMessageOrdering \n      ? new MessageOrderingService(this.redis)\n      : null;\n    \n    const server = createServer();\n    this.wss = new WebSocket.Server({ \n      server,\n      verifyClient: this.verifyClient.bind(this),\n      maxPayload: config.maxMessageSize\n    });\n    \n    server.listen(config.port);\n    this.setupEventHandlers();\n    this.startHeartbeat(config.heartbeatInterval);\n    this.setupGracefulShutdown();\n    this.startBackgroundJobs();\n  }\n\n  private async verifyClient(\n    info: { origin: string; req: IncomingMessage },\n    callback: (result: boolean, code?: number, message?: string) => void\n  ): Promise<void> {\n    try {\n      if (this.isShuttingDown) {\n        callback(false, 503, 'Server shutting down');\n        return;\n      }\n\n      const token = this.extractToken(info.req);\n      if (!token) {\n        callback(false, 401, 'Missing authentication token');\n        return;\n      }\n\n      const user = await this.auth.validateToken(token);\n      if (!user) {\n        callback(false, 401, 'Invalid or expired token');\n        return;\n      }\n      \n      // Check connection limit per user\n      const userConnections = await this.redis.getUserConnectionCount(user.id);\n      if (userConnections >= this.config.maxConnectionsPerUser) {\n        // NEW: Allow explicit disconnect of oldest connection if requested\n        const forceReconnect = info.req.headers['x-force-reconnect'] === 'true';\n        if (forceReconnect) {\n          await this.disconnectOldestConnection(user.id);\n        } else {\n          callback(false, 429, 'Connection limit exceeded');\n          return;\n        }\n      }\n      \n      (info.req as any).user = user;\n      callback(true);\n    } catch (error) {\n      console.error('Error in verifyClient:', error);\n      this.metrics.recordError('verify_client', error);\n      callback(false, 500, 'Authentication service unavailable');\n    }\n  }\n\n  private setupEventHandlers(): void {\n    this.wss.on('connection', this.handleConnection.bind(this));\n    \n    // Subscribe to notification channel\n    this.redis.subscribe('notifications', this.handleNotification.bind(this));\n    \n    // NEW: Subscribe to cross-server commands\n    this.redis.subscribe('server:commands', this.handleServerCommand.bind(this));\n    \n    this.wss.on('error', (error) => {\n      console.error('WebSocket server error:', error);\n      this.metrics.recordError('server', error);\n    });\n  }\n\n  private async handleConnection(ws: WebSocket, req: IncomingMessage): Promise<void> {\n    const user = (req as any).user;\n    const connectionId = this.generateConnectionId();\n    \n    try {\n      // Get last seen sequence for this user (for ordering)\n      const lastSeq = this.messageOrdering \n        ? await this.messageOrdering.getLastSeenSequence(user.id)\n        : null;\n\n      // Store connection metadata\n      await this.store.addConnection({\n        connectionId,\n        userId: user.id,\n        serverId: this.serverId,\n        connectedAt: new Date(),\n        lastSeenSequence: lastSeq || 0,\n        metadata: {\n          userAgent: req.headers['user-agent'],\n          ip: this.extractClientIp(req),\n          protocol: req.headers['sec-websocket-protocol']\n        }\n      });\n\n      // Register in Redis for cross-server routing\n      await this.redis.addUserConnection(user.id, connectionId, this.serverId);\n\n      // Add to in-memory map\n      if (!this.connections.has(user.id)) {\n        this.connections.set(user.id, new Set());\n      }\n      this.connections.get(user.id)!.add(ws);\n\n      // Attach metadata\n      (ws as any).userId = user.id;\n      (ws as any).connectionId = connectionId;\n      (ws as any).isAlive = true;\n      (ws as any).connectedAt = Date.now();\n      (ws as any).lastSeenSequence = lastSeq || 0;\n\n      // Event handlers\n      ws.on('pong', () => {\n        (ws as any).isAlive = true;\n      });\n\n      ws.on('message', async (data: Buffer) => {\n        try {\n          await this.handleMessage(ws, user.id, data.toString('utf8'));\n        } catch (error) {\n          console.error(`Error handling message from user ${user.id}:`, error);\n          this.metrics.recordError('message_handling', error);\n        }\n      });\n\n      ws.on('close', async (code: number, reason: Buffer) => {\n        await this.handleDisconnection(ws, user.id, connectionId);\n        this.metrics.recordDisconnection(code, reason.toString());\n      });\n\n      ws.on('error', (error) => {\n        console.error(`WebSocket error for user ${user.id}:`, error);\n        this.metrics.recordError('websocket', error);\n      });\n\n      // Send connection acknowledgment\n      this.sendMessage(ws, {\n        type: 'connected',\n        connectionId,\n        serverId: this.serverId,\n        timestamp: Date.now(),\n        lastSeenSequence: lastSeq || 0,\n        capabilities: {\n          maxMessageSize: this.config.maxMessageSize,\n          heartbeatInterval: this.config.heartbeatInterval,\n          messageOrdering: this.config.enableMessageOrdering,\n          supportedFeatures: ['subscriptions', 'priorities', 'acknowledgments', 'ordering']\n        }\n      });\n\n      // NEW: Deliver missed notifications with optional ordering\n      await this.deliverMissedNotifications(ws, user.id, lastSeq || 0);\n\n      this.metrics.recordConnection(user.id);\n    } catch (error) {\n      console.error('Error during connection setup:', error);\n      this.metrics.recordError('connection_setup', error);\n      ws.close(1011, 'Internal server error');\n    }\n  }\n\n  private async handleDisconnection(\n    ws: WebSocket,\n    userId: string,\n    connectionId: string\n  ): Promise<void> {\n    try {\n      // Update last seen sequence before disconnecting\n      if (this.messageOrdering) {\n        const lastSeq = (ws as any).lastSeenSequence;\n        await this.messageOrdering.updateLastSeenSequence(userId, lastSeq);\n      }\n\n      // Remove from in-memory map\n      const userConnections = this.connections.get(userId);\n      if (userConnections) {\n        userConnections.delete(ws);\n        if (userConnections.size === 0) {\n          this.connections.delete(userId);\n        }\n      }\n\n      // Remove from Redis\n      await this.redis.removeUserConnection(userId, connectionId);\n\n      // Archive connection record (soft delete for audit trail)\n      await this.store.archiveConnection(connectionId);\n\n      // Record session metrics\n      const duration = Date.now() - (ws as any).connectedAt;\n      this.metrics.recordSessionDuration(userId, duration);\n    } catch (error) {\n      console.error('Error during disconnection cleanup:', error);\n      this.metrics.recordError('disconnection', error);\n    }\n  }\n\n  private async handleNotification(message: string): Promise<void> {\n    try {\n      const notification = JSON.parse(message) as Notification;\n      \n      // Check expiration\n      if (notification.expiresAt && new Date(notification.expiresAt) < new Date()) {\n        console.log(`Notification ${notification.id} expired, skipping delivery`);\n        await this.store.markExpired(notification.id);\n        return;\n      }\n\n      // Get target user connections on this server\n      const userConnections = this.connections.get(notification.userId);\n      \n      if (userConnections && userConnections.size > 0) {\n        let deliveredCount = 0;\n        \n        for (const ws of userConnections) {\n          if (await this.shouldDeliverNotification(ws, notification)) {\n            if (ws.readyState === WebSocket.OPEN) {\n              // Update sequence tracking if enabled\n              if (this.messageOrdering && notification.sequence) {\n                (ws as any).lastSeenSequence = notification.sequence;\n              }\n              \n              this.sendMessage(ws, {\n                type: 'notification',\n                payload: notification,\n                sequence: notification.sequence,\n                timestamp: Date.now()\n              });\n              deliveredCount++;\n            }\n          }\n        }\n        \n        if (deliveredCount > 0) {\n          await this.store.markDelivered(\n            notification.id,\n            this.serverId,\n            deliveredCount,\n            new Date()\n          );\n          this.metrics.recordNotificationDelivered(notification.type, deliveredCount);\n        } else {\n          // User connected but no delivery (e.g., channel mismatch)\n          await this.store.markPendingDelivery(notification.id, notification.userId);\n        }\n      } else {\n        // User not connected to this server\n        await this.store.markPendingDelivery(notification.id, notification.userId);\n        this.metrics.recordNotificationPending(notification.type);\n      }\n    } catch (error) {\n      console.error('Error handling notification:', error);\n      this.metrics.recordError('notification_handling', error);\n      \n      // NEW: Dead letter queue for failed notifications\n      await this.store.moveToDeadLetterQueue(notification.id, error.message);\n    }\n  }\n\n  private async shouldDeliverNotification(\n    ws: WebSocket,\n    notification: Notification\n  ): Promise<boolean> {\n    const connectionId = (ws as any).connectionId;\n    \n    // Check channel subscriptions\n    if (notification.channels && notification.channels.length > 0) {\n      const subscriptions = await this.redis.getSubscriptions(connectionId);\n      \n      // NEW: Support wildcard matching\n      const matchesSubscription = notification.channels.some(channel => \n        subscriptions.some(sub => this.matchesPattern(channel, sub))\n      );\n      \n      if (!matchesSubscription) {\n        return false;\n      }\n    }\n    \n    // NEW: Check user preferences (e.g., do not disturb)\n    const preferences = await this.store.getUserPreferences((ws as any).userId);\n    if (preferences.doNotDisturb && notification.priority !== 'urgent') {\n      return false;\n    }\n    \n    return true;\n  }\n\n  // NEW: Pattern matching for wildcard subscriptions\n  private matchesPattern(channel: string, pattern: string): boolean {\n    if (!pattern.includes('*')) {\n      return channel === pattern;\n    }\n    \n    const regexPattern = pattern\n      .replace(/\\./g, '\\\\.')\n      .replace(/\\*/g, '.*');\n    \n    return new RegExp(`^${regexPattern}$`).test(channel);\n  }\n\n  private async handleMessage(ws: WebSocket, userId: string, data: string): Promise<void> {\n    if (!this.rateLimiter.allowMessage(userId)) {\n      this.sendMessage(ws, {\n        type: 'error',\n        error: 'Rate limit exceeded',\n        code: 'RATE_LIMIT_EXCEEDED',\n        retryAfter: this.rateLimiter.getRetryAfter(userId)\n      });\n      return;\n    }\n\n    try {\n      const message = JSON.parse(data);\n      \n      if (!message.type) {\n        throw new Error('Message type required');\n      }\n      \n      switch (message.type) {\n        case 'ping':\n          this.sendMessage(ws, { type: 'pong', timestamp: Date.now() });\n          break;\n        \n        case 'subscribe':\n          await this.handleSubscribe(ws, userId, message.channels);\n          break;\n        \n        case 'unsubscribe':\n          await this.handleUnsubscribe(ws, userId, message.channels);\n          break;\n        \n        case 'ack':\n          await this.handleAcknowledgment(ws, userId, message.notificationId);\n          break;\n        \n        // NEW: Batch acknowledgment\n        case 'ack_batch':\n          await this.handleBatchAcknowledgment(ws, userId, message.notificationIds);\n          break;\n        \n        // NEW: Request missed notifications\n        case 'request_missed':\n          await this.deliverMissedNotifications(\n            ws, \n            userId, \n            message.fromSequence || 0,\n            message.limit || 50\n          );\n          break;\n        \n        default:\n          this.sendMessage(ws, {\n            type: 'error',\n            error: 'Unknown message type',\n            code: 'UNKNOWN_MESSAGE_TYPE'\n          });\n      }\n    } catch (error) {\n      console.error('Error parsing/handling message:', error);\n      this.sendMessage(ws, {\n        type: 'error',\n        error: error instanceof Error ? error.message : 'Invalid message format',\n        code: 'MESSAGE_PARSE_ERROR'\n      });\n    }\n  }\n\n  private async handleSubscribe(\n    ws: WebSocket,\n    userId: string,\n    channels: string[]\n  ): Promise<void> {\n    if (!Array.isArray(channels) || channels.length === 0) {\n      this.sendMessage(ws, {\n        type: 'error',\n        error: 'Invalid channels array',\n        code: 'INVALID_CHANNELS'\n      });\n      return;\n    }\n\n    const connectionId = (ws as any).connectionId;\n    \n    // Store subscriptions in Redis (faster access)\n    await this.redis.addSubscriptions(connectionId, channels);\n    \n    // Also persist to DB for recovery\n    await this.store.addSubscriptions(connectionId, channels);\n    \n    this.sendMessage(ws, {\n      type: 'subscribed',\n      channels,\n      timestamp: Date.now()\n    });\n\n    this.metrics.recordSubscription(channels.length);\n  }\n\n  private async handleUnsubscribe(\n    ws: WebSocket,\n    userId: string,\n    channels: string[]\n  ): Promise<void> {\n    if (!Array.isArray(channels) || channels.length === 0) {\n      this.sendMessage(ws, {\n        type: 'error',\n        error: 'Invalid channels array',\n        code: 'INVALID_CHANNELS'\n      });\n      return;\n    }\n\n    const connectionId = (ws as any).connectionId;\n    \n    await this.redis.removeSubscriptions(connectionId, channels);\n    await this.store.removeSubscriptions(connectionId, channels);\n    \n    this.sendMessage(ws, {\n      type: 'unsubscribed',\n      channels,\n      timestamp: Date.now()\n    });\n\n    this.metrics.recordUnsubscription(channels.length);\n  }\n\n  private async handleAcknowledgment(\n    ws: WebSocket,\n    userId: string,\n    notificationId: string\n  ): Promise<void> {\n    try {\n      await this.store.markAcknowledged(notificationId, userId, new Date());\n      \n      // Remove from pending\n      await this.store.removePendingNotification(notificationId, userId);\n      \n      this.metrics.recordAcknowledgment();\n    } catch (error) {\n      console.error('Error acknowledging notification:', error);\n      this.sendMessage(ws, {\n        type: 'error',\n        error: 'Failed to acknowledge notification',\n        code: 'ACK_FAILED'\n      });\n    }\n  }\n\n  // NEW: Batch acknowledgment for efficiency\n  private async handleBatchAcknowledgment(\n    ws: WebSocket,\n    userId: string,\n    notificationIds: string[]\n  ): Promise<void> {\n    if (!Array.isArray(notificationIds) || notificationIds.length === 0) {\n      this.sendMessage(ws, {\n        type: 'error',\n        error: 'Invalid notification IDs array',\n        code: 'INVALID_ACK_BATCH'\n      });\n      return;\n    }\n\n    try {\n      await this.store.markAcknowledgedBatch(notificationIds, userId, new Date());\n      await this.store.removePendingNotificationsBatch(notificationIds, userId);\n      \n      this.metrics.recordAcknowledgment(notificationIds.length);\n      \n      this.sendMessage(ws, {\n        type: 'ack_batch_success',\n        count: notificationIds.length,\n        timestamp: Date.now()\n      });\n    } catch (error) {\n      console.error('Error in batch acknowledgment:', error);\n      this.sendMessage(ws, {\n        type: 'error',\n        error: 'Failed to acknowledge notifications',\n        code: 'ACK_BATCH_FAILED'\n      });\n    }\n  }\n\n  // NEW: Enhanced missed notification delivery with ordering\n  private async deliverMissedNotifications(\n    ws: WebSocket,\n    userId: string,\n    fromSequence: number = 0,\n    limit: number = 50\n  ): Promise<void> {\n    try {\n      const missedNotifications = this.messageOrdering\n        ? await this.store.getPendingNotificationsOrdered(userId, fromSequence, limit)\n        : await this.store.getPendingNotifications(userId, limit);\n      \n      let deliveredCount = 0;\n      \n      for (const notification of missedNotifications) {\n        if (ws.readyState === WebSocket.OPEN) {\n          this.sendMessage(ws, {\n            type: 'notification',\n            payload: notification,\n            sequence: notification.sequence,\n            timestamp: Date.now(),\n            missed: true\n          });\n          \n          // Update last seen sequence\n          if (this.messageOrdering && notification.sequence) {\n            (ws as any).lastSeenSequence = notification.sequence;\n          }\n          \n          deliveredCount++;\n        } else {\n          break; // Connection closed during delivery\n        }\n      }\n\n      if (deliveredCount > 0) {\n        this.metrics.recordMissedNotificationsDelivered(deliveredCount);\n        \n        // Send completion marker\n        this.sendMessage(ws, {\n          type: 'missed_notifications_complete',\n          count: deliveredCount,\n          hasMore: missedNotifications.length === limit,\n          timestamp: Date.now()\n        });\n      }\n    } catch (error) {\n      console.error('Error sending missed notifications:', error);\n      this.metrics.recordError('missed_notifications', error);\n      \n      this.sendMessage(ws, {\n        type: 'error',\n        error: 'Failed to retrieve missed notifications',\n        code: 'MISSED_NOTIFICATIONS_FAILED'\n      });\n    }\n  }\n\n  // NEW: Disconnect oldest connection for force reconnect\n  private async disconnectOldestConnection(userId: string): Promise<void> {\n    const connections = await this.redis.getUserConnections(userId);\n    \n    if (connections.length === 0) return;\n    \n    // Sort by connection time (embedded in connection ID)\n    connections.sort((a, b) => \n      a.connectionId.localeCompare(b.connectionId)\n    );\n    \n    const oldest = connections[0];\n    \n    // Send disconnect command to the server holding the connection\n    await this.redis.publish('server:commands', {\n      command: 'disconnect',\n      serverId: oldest.serverId,\n      connectionId: oldest.connectionId,\n      reason: 'Connection limit exceeded - forced reconnect'\n    });\n  }\n\n  // NEW: Handle cross-server commands\n  private async handleServerCommand(message: string): Promise<void> {\n    try {\n      const command = JSON.parse(message);\n      \n      if (command.serverId !== this.serverId) {\n        return; // Not for this server\n      }\n      \n      switch (command.command) {\n        case 'disconnect':\n          await this.forceDisconnectConnection(command.connectionId, command.reason);\n          break;\n        \n        default:\n          console.warn(`Unknown server command: ${command.command}`);\n      }\n    } catch (error) {\n      console.error('Error handling server command:', error);\n    }\n  }\n\n  private async forceDisconnectConnection(\n    connectionId: string,\n    reason: string\n  ): Promise<void> {\n    // Find connection in memory\n    for (const [userId, connections] of this.connections.entries()) {\n      for (const ws of connections) {\n        if ((ws as any).connectionId === connectionId) {\n          this.sendMessage(ws, {\n            type: 'force_disconnect',\n            reason,\n            timestamp: Date.now()\n          });\n          \n          ws.close(1008, reason);\n          return;\n        }\n      }\n    }\n  }\n\n  private startHeartbeat(interval: number): void {\n    setInterval(() => {\n      this.wss.clients.forEach((ws: WebSocket) => {\n        if (!(ws as any).isAlive) {\n          console.log(`Terminating dead connection: ${(ws as any).connectionId}`);\n          return ws.terminate();\n        }\n        \n        (ws as any).isAlive = false;\n        ws.ping();\n      });\n      \n      this.metrics.recordHeartbeat(this.wss.clients.size);\n    }, interval);\n  }\n\n  // NEW: Background jobs for maintenance\n  private startBackgroundJobs(): void {\n    // Cleanup expired notifications every hour\n    setInterval(async () => {\n      try {\n        const deleted = await this.store.cleanupExpiredNotifications();\n        console.log(`Cleaned up ${deleted} expired notifications`);\n      } catch (error) {\n        console.error('Error in cleanup job:', error);\n      }\n    }, 3600000); // 1 hour\n\n    // Cleanup old archived connections every 24 hours\n    setInterval(async () => {\n      try {\n        const deleted = await this.store.cleanupArchivedConnections(this.config.offlineRetentionDays);\n        console.log(`Cleaned up ${deleted} archived connections`);\n      } catch (error) {\n        console.error('Error in archive cleanup job:', error);\n      }\n    }, 86400000); // 24 hours\n\n    // Sync Redis connection state with DB every 5 minutes (recover from Redis failures)\n    setInterval(async () => {\n      try {\n        await this.syncConnectionState();\n      } catch (error) {\n        console.error('Error syncing connection state:', error);\n      }\n    }, 300000); // 5 minutes\n  }\n\n  private async syncConnectionState(): Promise<void> {\n    // Get connections from DB for this server\n    const dbConnections = await this.store.getServerConnections(this.serverId);\n    \n    // Get connections from memory\n    const memoryConnections = new Set<string>();\n    for (const connections of this.connections.values()) {\n      for (const ws of connections) {\n        memoryConnections.add((ws as any).connectionId);\n      }\n    }\n    \n    // Find orphaned DB records (in DB but not in memory)\n    for (const dbConn of dbConnections) {\n      if (!memoryConnections.has(dbConn.connectionId)) {\n        console.log(`Cleaning up orphaned connection: ${dbConn.connectionId}`);\n        await this.store.archiveConnection(dbConn.connectionId);\n        await this.redis.removeUserConnection(dbConn.userId, dbConn.connectionId);\n      }\n    }\n  }\n\n  private setupGracefulShutdown(): void {\n    const shutdown = async (signal: string) => {\n      console.log(`${signal} received, starting graceful shutdown...`);\n      this.isShuttingDown = true;\n\n      // Stop accepting new connections\n      this.wss.close();\n\n      // Send shutdown notice\n      this.wss.clients.forEach((ws: WebSocket) => {\n        this.sendMessage(ws, {\n          type: 'server_shutdown',\n          message: 'Server shutting down, please reconnect',\n          timestamp: Date.now()\n        });\n      });\n\n      // Wait for clients to disconnect\n      const shutdownPromise = new Promise<void>((resolve) => {\n        const checkInterval = setInterval(() => {\n          if (this.wss.clients.size === 0) {\n            clearInterval(checkInterval);\n            resolve();\n          }\n        }, 100);\n\n        setTimeout(() => {\n          clearInterval(checkInterval);\n          resolve();\n        }, this.config.gracefulShutdownTimeout);\n      });\n\n      await shutdownPromise;\n\n      // Close remaining connections\n      this.wss.clients.forEach(ws => ws.terminate());\n\n      // Cleanup resources\n      await this.redis.disconnect();\n      await this.store.disconnect();\n\n      console.log('Graceful shutdown complete');\n      process.exit(0);\n    };\n\n    process.on('SIGTERM', () => shutdown('SIGTERM'));\n    process.on('SIGINT', () => shutdown('SIGINT'));\n  }\n\n  private sendMessage(ws: WebSocket, message: any): void {\n    if (ws.readyState === WebSocket.OPEN) {\n      try {\n        ws.send(JSON.stringify(message));\n      } catch (error) {\n        console.error('Error sending message:', error);\n        this.metrics.recordError('send_message', error);\n      }\n    }\n  }\n\n  private generateConnectionId(): string {\n    return `${this.serverId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private extractToken(req: IncomingMessage): string | null {\n    const authHeader = req.headers.authorization;\n    if (authHeader?.startsWith('Bearer ')) {\n      return authHeader.substring(7);\n    }\n    \n    const url = new URL(req.url!, `http://${req.headers.host}`);\n    return url.searchParams.get('token');\n  }\n\n  private extractClientIp(req: IncomingMessage): string {\n    const forwarded = req.headers['x-forwarded-for'];\n    if (typeof forwarded === 'string') {\n      return forwarded.split(',')[0].trim();\n    }\n    return req.socket.remoteAddress || 'unknown';\n  }\n}\n```\n\n### 2. Message Ordering Service\n\n```typescript\n// message-ordering.ts\nimport { RedisClient } from './redis-client';\n\nexport class MessageOrderingService {\n  private redis: RedisClient;\n  private sequenceKey = 'notification:sequence';\n\n  constructor(redis: RedisClient) {\n    this.redis = redis;\n  }\n\n  async getNextSequence(): Promise<number> {\n    return await this.redis.incrementSequence(this.sequenceKey);\n  }\n\n  async getLastSeenSequence(userId: string): Promise<number> {\n    return await this.redis.getLastSeenSequence(userId);\n  }\n\n  async updateLastSeenSequence(userId: string, sequence: number): Promise<void> {\n    await this.redis.setLastSeenSequence(userId, sequence);\n  }\n}\n```\n\n### 3. Enhanced Redis Client\n\n```typescript\n// redis-client.ts\nimport { createClient, RedisClientType } from 'redis';\n\nexport class RedisClient {\n  private client: RedisClientType;\n  private publisher: RedisClientType;\n  private subscriber: RedisClientType;\n  private isConnected: boolean = false;\n  private reconnectAttempts: number = 0;\n  private maxReconnectAttempts: number = 10;\n\n  constructor(url: string) {\n    const config = {\n      url,\n      socket: {\n        reconnectStrategy: (retries: number) => {\n          this.reconnectAttempts = retries;\n          \n          if (retries > this.maxReconnectAttempts) {\n            console.error('Max Redis reconnection attempts reached');\n            return new Error('Max reconnection attempts reached');\n          }\n          \n          const delay = Math.min(retries * 100, 3000);\n          console.log(`Reconnecting to Redis (attempt ${retries}) in ${delay}ms`);\n          return delay;\n        }\n      }\n    };\n\n    this.client = createClient(config);\n    this.publisher = this.client.duplicate();\n    this.subscriber = this.client.duplicate();\n    \n    this.setupErrorHandlers();\n    this.connect();\n  }\n\n  private setupErrorHandlers(): void {\n    [this.client, this.publisher, this.subscriber].forEach(client => {\n      client.on('error', (err) => {\n        console.error('Redis client error:', err);\n      });\n\n      client.on('connect', () => {\n        console.log('Redis client connected');\n        this.isConnected = true;\n        this.reconnectAttempts = 0;\n      });\n\n      client.on('disconnect', () => {\n        console.log('Redis client disconnected');\n        this.isConnected = false;\n      });\n\n      client.on('reconnecting', () => {\n        console.log('Redis client reconnecting...');\n      });\n    });\n  }\n\n  private async connect(): Promise<void> {\n    try {\n      await Promise.all([\n        this.client.connect(),\n        this.publisher.connect(),\n        this.subscriber.connect()\n      ]);\n    } catch (error) {\n      console.error('Failed to connect to Redis:', error);\n      throw error;\n    }\n  }\n\n  async publish(channel: string, message: any): Promise<void> {\n    if (!this.isConnected) {\n      throw new Error('Redis not connected');\n    }\n\n    try {\n      await this.publisher.publish(channel, JSON.stringify(message));\n    } catch (error) {\n      console.error('Failed to publish message:', error);\n      throw error;\n    }\n  }\n\n  async subscribe(\n    channel: string,\n    handler: (message: string) => void\n  ): Promise<void> {\n    await this.subscriber.subscribe(channel, handler);\n  }\n\n  async addUserConnection(userId: string, connectionId: string, serverId: string): Promise<void> {\n    const pipeline = this.client.multi();\n    pipeline.hSet(`connection:${connectionId}`, {\n      userId,\n      serverId,\n      connectedAt: Date.now()\n    });\n    pipeline.sAdd(`user:${userId}:connections`, connectionId);\n    pipeline.expire(`connection:${connectionId}`, 86400);\n    pipeline.expire(`user:${userId}:connections`, 86400);\n    await pipeline.exec();\n  }\n\n  async removeUserConnection(userId: string, connectionId: string): Promise<void> {\n    const pipeline = this.client.multi();\n    pipeline.del(`connection:${connectionId}`);\n    pipeline.sRem(`user:${userId}:connections`, connectionId);\n    await pipeline.exec();\n  }\n\n  async getUserConnections(userId: string): Promise<Array<{connectionId: string, serverId: string}>> {\n    const connectionIds = await this.client.sMembers(`user:${userId}:connections`);\n    const connections = await Promise.all(\n      connectionIds.map(async (id) => {\n        const data = await this.client.hGetAll(`connection:${id}`);\n        return { connectionId: id, serverId: data.serverId };\n      })\n    );\n    return connections.filter(c => c.serverId);\n  }\n\n  async getUserConnectionCount(userId: string): Promise<number> {\n    return await this.client.sCard(`user:${userId}:connections`);\n  }\n\n  // NEW: Subscription management in Redis for fast access\n  async addSubscriptions(connectionId: string, channels: string[]): Promise<void> {\n    if (channels.length === 0) return;\n    \n    await this.client.sAdd(`connection:${connectionId}:subscriptions`, channels);\n    await this.client.expire(`connection:${connectionId}:subscriptions`, 86400);\n  }\n\n  async removeSubscriptions(connectionId: string, channels: string[]): Promise<void> {\n    if (channels.length === 0) return;\n    \n    await this.client.sRem(`connection:${connectionId}:subscriptions`, channels);\n  }\n\n  async getSubscriptions(connectionId: string): Promise<string[]> {\n    return await this.client.sMembers(`connection:${connectionId}:subscriptions`);\n  }\n\n  // NEW: Sequence number management\n  async incrementSequence(key: string): Promise<number> {\n    return await this.client.incr(key);\n  }\n\n  async getLastSeenSequence(userId: string): Promise<number> {\n    const seq = await this.client.get(`user:${userId}:last_seq`);\n    return seq ? parseInt(seq) : 0;\n  }\n\n  async setLastSeenSequence(userId: string, sequence: number): Promise<void> {\n    await this.client.set(`user:${userId}:last_seq`, sequence, { EX: 2592000 }); // 30 days\n  }\n\n  async disconnect(): Promise<void> {\n    await Promise.all([\n      this.client.quit(),\n      this.publisher.quit(),\n      this.subscriber.quit()\n    ]);\n  }\n\n  isHealthy(): boolean {\n    return this.isConnected && this.reconnectAttempts < this.maxReconnectAttempts;\n  }\n}\n```\n\n### 4. Enhanced Notification Store\n\n```typescript\n// notification-store.ts\nimport { Pool, PoolClient } from 'pg';\n\ninterface Connection {\n  connectionId: string;\n  userId: string;\n  serverId: string;\n  connectedAt: Date;\n  lastSeenSequence: number;\n  metadata: Record<string, any>;\n}\n\ninterface Notification {\n  id: string;\n  userId: string;\n  type: string;\n  payload: any;\n  priority: string;\n  channels?: string[];\n  sequence?: number;\n  expiresAt?: Date;\n}\n\ninterface UserPreferences {\n  doNotDisturb: boolean;\n  quietHoursStart?: string;\n  quietHoursEnd?: string;\n  allowedPriorities?: string[];\n}\n\nexport class NotificationStore {\n  private pool: Pool;\n\n  constructor(connectionString: string) {\n    this.pool = new Pool({\n      connectionString,\n      max: 20,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: 2000,\n    });\n\n    this.pool.on('error', (err) => {\n      console.error('Unexpected database error:', err);\n    });\n  }\n\n  async addConnection(connection: Connection): Promise<void> {\n    await this.pool.query(\n      `INSERT INTO connections (connection_id, user_id, server_id, connected_at, last_seen_sequence, metadata, archived)\n       VALUES ($1, $2, $3, $4, $5, $6, false)\n       ON CONFLICT (connection_id) DO UPDATE SET\n         connected_at = EXCLUDED.connected_at,\n         last_seen_sequence = EXCLUDED.last_seen_sequence,\n         metadata = EXCLUDED.metadata,\n         archived = false`,\n      [\n        connection.connectionId,\n        connection.userId,\n        connection.serverId,\n        connection.connectedAt,\n        connection.lastSeenSequence,\n        JSON.stringify(connection.metadata)\n      ]\n    );\n  }\n\n  async archiveConnection(connectionId: string): Promise<void> {\n    await this.pool.query(\n      `UPDATE connections SET archived = true, archived_at = NOW()\n       WHERE connection_id = $1`,\n      [connectionId]\n    );\n  }\n\n  async getServerConnections(serverId: string): Promise<Array<{connectionId: string, userId: string}>> {\n    const result = await this.pool.query(\n      `SELECT connection_id, user_id \n       FROM connections \n       WHERE server_id = $1 AND archived = false`,\n      [serverId]\n    );\n    return result.rows.map(row => ({\n      connectionId: row.connection_id,\n      userId: row.user_id\n    }));\n  }\n\n  async getConnectionCount(userId: string): Promise<number> {\n    const result = await this.pool.query(\n      `SELECT COUNT(*) as count \n       FROM connections \n       WHERE user_id = $1 AND archived = false`,\n      [userId]\n    );\n    return parseInt(result.rows[0].count);\n  }\n\n  async addSubscriptions(connectionId: string, channels: string[]): Promise<void> {\n    if (channels.length === 0) return;\n\n    const values = channels.map((channel, i) => \n      `($1, $${i + 2})`\n    ).join(',');\n    \n    await this.pool.query(\n      `INSERT INTO subscriptions (connection_id, channel)\n       VALUES ${values}\n       ON CONFLICT (connection_id, channel) DO NOTHING`,\n      [connectionId, ...channels]\n    );\n  }\n\n  async removeSubscriptions(connectionId: string, channels: string[]): Promise<void> {\n    await this.pool.query(\n      `DELETE FROM subscriptions \n       WHERE connection_id = $1 AND channel = ANY($2)`,\n      [connectionId, channels]\n    );\n  }\n\n  async markDelivered(\n    notificationId: string, \n    serverId: string, \n    recipientCount: number,\n    deliveredAt: Date\n  ): Promise<void> {\n    await this.pool.query(\n      `INSERT INTO notification_delivery (notification_id, server_id, delivered_at, recipient_count)\n       VALUES ($1, $2, $3, $4)`,\n      [notificationId, serverId, deliveredAt, recipientCount]\n    );\n  }\n\n  async markPendingDelivery(notificationId: string, userId: string): Promise<void> {\n    await this.pool.query(\n      `INSERT INTO pending_notifications (notification_id, user_id, created_at)\n       VALUES ($1, $2, NOW())\n       ON CONFLICT (notification_id, user_id) DO NOTHING`,\n      [notificationId, userId]\n    );\n  }\n\n  async markExpired(notificationId: string): Promise<void> {\n    await this.pool.query(\n      `UPDATE notifications SET status = 'expired' WHERE id = $1`,\n      [notificationId]\n    );\n  }\n\n  async markAcknowledged(notificationId: string, userId: string, acknowledgedAt: Date): Promise<void> {\n    const client = await this.pool.connect();\n    try {\n      await client.query('BEGIN');\n      \n      await client.query(\n        `UPDATE notification_delivery \n         SET acknowledged_at = $2\n         WHERE notification_id = $1`,\n        [notificationId, acknowledgedAt]\n      );\n\n      await client.query(\n        `DELETE FROM pending_notifications\n         WHERE notification_id = $1 AND user_id = $2`,\n        [notificationId, userId]\n      );\n\n      await client.query('COMMIT');\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  // NEW: Batch acknowledgment\n  async markAcknowledgedBatch(\n    notificationIds: string[], \n    userId: string, \n    acknowledgedAt: Date\n  ): Promise<void> {\n    const client = await this.pool.connect();\n    try {\n      await client.query('BEGIN');\n      \n      await client.query(\n        `UPDATE notification_delivery \n         SET acknowledged_at = $2\n         WHERE notification_id = ANY($1)`,\n        [notificationIds, acknowledgedAt]\n      );\n\n      await client.query(\n        `DELETE FROM pending_notifications\n         WHERE notification_id = ANY($1) AND user_id = $2`,\n        [notificationIds, userId]\n      );\n\n      await client.query('COMMIT');\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  async removePendingNotification(notificationId: string, userId: string): Promise<void> {\n    await this.pool.query(\n      `DELETE FROM pending_notifications\n       WHERE notification_id = $1 AND user_id = $2`,\n      [notificationId, userId]\n    );\n  }\n\n  async removePendingNotificationsBatch(notificationIds: string[], userId: string): Promise<void> {\n    await this.pool.query(\n      `DELETE FROM pending_notifications\n       WHERE notification_id = ANY($1) AND user_id = $2`,\n      [notificationIds, userId]\n    );\n  }\n\n  async getPendingNotifications(userId: string, limit: number = 50): Promise<Notification[]> {\n    const result = await this.pool.query(\n      `SELECT n.id, n.user_id, n.type, n.payload, n.priority, n.channels, n.expires_at, n.sequence\n       FROM notifications n\n       INNER JOIN pending_notifications pn ON n.id = pn.notification_id\n       WHERE pn.user_id = $1 \n         AND (n.expires_at IS NULL OR n.expires_at > NOW())\n         AND n.status = 'pending'\n       ORDER BY n.priority DESC, n.created_at ASC\n       LIMIT $2`,\n      [userId, limit]\n    );\n\n    return result.rows.map(row => ({\n      id: row.id,\n      userId: row.user_id,\n      type: row.type,\n      payload: row.payload,\n      priority: row.priority,\n      channels: row.channels,\n      sequence: row.sequence,\n      expiresAt: row.expires_at\n    }));\n  }\n\n  // NEW: Ordered pending notifications\n  async getPendingNotificationsOrdered(\n    userId: string, \n    fromSequence: number,\n    limit: number = 50\n  ): Promise<Notification[]> {\n    const result = await this.pool.query(\n      `SELECT n.id, n.user_id, n.type, n.payload, n.priority, n.channels, n.expires_at, n.sequence\n       FROM notifications n\n       INNER JOIN pending_notifications pn ON n.id = pn.notification_id\n       WHERE pn.user_id = $1 \n         AND n.sequence > $2\n         AND (n.expires_at IS NULL OR n.expires_at > NOW())\n         AND n.status = 'pending'\n       ORDER BY n.sequence ASC\n       LIMIT $3`,\n      [userId, fromSequence, limit]\n    );\n\n    return result.rows.map(row => ({\n      id: row.id,\n      userId: row.user_id,\n      type: row.type,\n      payload: row.payload,\n      priority: row.priority,\n      channels: row.channels,\n      sequence: row.sequence,\n      expiresAt: row.expires_at\n    }));\n  }\n\n  // NEW: User preferences\n  async getUserPreferences(userId: string): Promise<UserPreferences> {\n    const result = await this.pool.query(\n      `SELECT do_not_disturb, quiet_hours_start, quiet_hours_end, allowed_priorities\n       FROM user_preferences\n       WHERE user_id = $1`,\n      [userId]\n    );\n\n    if (result.rows.length === 0) {\n      return { doNotDisturb: false };\n    }\n\n    const row = result.rows[0];\n    return {\n      doNotDisturb: row.do_not_disturb,\n      quietHoursStart: row.quiet_hours_start,\n      quietHoursEnd: row.quiet_hours_end,\n      allowedPriorities: row.allowed_priorities\n    };\n  }\n\n  // NEW: Dead letter queue\n  async moveToDeadLetterQueue(notificationId: string, errorMessage: string): Promise<void> {\n    await this.pool.query(\n      `INSERT INTO dead_letter_queue (notification_id, error_message, failed_at)\n       VALUES ($1, $2, NOW())`,\n      [notificationId, errorMessage]\n    );\n  }\n\n  async cleanupExpiredNotifications(): Promise<number> {\n    const result = await this.pool.query(\n      `DELETE FROM notifications \n       WHERE expires_at IS NOT NULL AND expires_at < NOW()\n       RETURNING id`\n    );\n    return result.rowCount || 0;\n  }\n\n  async cleanupArchivedConnections(olderThanDays: number): Promise<number> {\n    const result = await this.pool.query(\n      `DELETE FROM connections \n       WHERE archived = true \n         AND archived_at < NOW() - INTERVAL '1 day' * $1\n       RETURNING connection_id`,\n      [olderThanDays]\n    );\n    return result.rowCount || 0;\n  }\n\n  async disconnect(): Promise<void> {\n    await this.pool.end();\n  }\n}\n```\n\n### 5. Enhanced Database Schema\n\n```sql\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- Connections table with archiving\nCREATE TABLE connections (\n  connection_id VARCHAR(255) PRIMARY KEY,\n  user_id VARCHAR(255) NOT NULL,\n  server_id VARCHAR(255) NOT NULL,\n  connected_at TIMESTAMP NOT NULL,\n  last_seen_sequence BIGINT DEFAULT 0,\n  metadata JSONB,\n  archived BOOLEAN DEFAULT false,\n  archived_at TIMESTAMP,\n  INDEX idx_user_id (user_id),\n  INDEX idx_server_id (server_id),\n  INDEX idx_archived (archived, archived_at) WHERE archived = true\n);\n\n-- Subscriptions table\nCREATE TABLE subscriptions (\n  id SERIAL PRIMARY KEY,\n  connection_id VARCHAR(255) NOT NULL,\n  channel VARCHAR(255) NOT NULL,\n  subscribed_at TIMESTAMP DEFAULT NOW(),\n  UNIQUE(connection_id, channel),\n  FOREIGN KEY (connection_id) REFERENCES connections(connection_id) ON DELETE CASCADE,\n  INDEX idx_connection_channel (connection_id, channel)\n);\n\n-- Notifications table with sequence number\nCREATE TABLE notifications (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id VARCHAR(255) NOT NULL,\n  type VARCHAR(100) NOT NULL,\n  payload JSONB NOT NULL,\n  priority VARCHAR(20) DEFAULT 'normal',\n  channels TEXT[],\n  sequence BIGINT,\n  status VARCHAR(20) DEFAULT 'pending',\n  created_at TIMESTAMP DEFAULT NOW(),\n  expires_at TIMESTAMP,\n  INDEX idx_user_created (user_id, created_at),\n  INDEX idx_sequence (sequence),\n  INDEX idx_expires (expires_at) WHERE expires_at IS NOT NULL,\n  INDEX idx_status_priority (status, priority) WHERE status = 'pending'\n);\n\n-- Notification delivery tracking\nCREATE TABLE notification_delivery (\n  id SERIAL PRIMARY KEY,\n  notification_id UUID NOT NULL,\n  server_id VARCHAR(255) NOT NULL,\n  delivered_at TIMESTAMP NOT NULL,\n  acknowledged_at TIMESTAMP,\n  recipient_count INTEGER DEFAULT 1,\n  FOREIGN KEY (notification_id) REFERENCES notifications(id) ON DELETE CASCADE,\n  INDEX idx_notification (notification_id),\n  INDEX idx_acknowledged (acknowledged_at) WHERE acknowledged_at IS NULL\n);\n\n-- Pending notifications (offline users)\nCREATE TABLE pending_notifications (\n  id SERIAL PRIMARY KEY,\n  notification_id UUID NOT NULL,\n  user_id VARCHAR(255) NOT NULL,\n  created_at TIMESTAMP DEFAULT NOW(),\n  UNIQUE(notification_id, user_id),\n  FOREIGN KEY (notification_id) REFERENCES notifications(id) ON DELETE CASCADE,\n  INDEX idx_user_pending (user_id, created_at)\n);\n\n-- NEW: User preferences\nCREATE TABLE user_preferences (\n  user_id VARCHAR(255) PRIMARY KEY,\n  do_not_disturb BOOLEAN DEFAULT false,\n  quiet_hours_start TIME,\n  quiet_hours_end TIME,\n  allowed_priorities TEXT[],\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- NEW: Dead letter queue for failed notifications\nCREATE TABLE dead_letter_queue (\n  id SERIAL PRIMARY KEY,\n  notification_id UUID NOT NULL,\n  error_message TEXT,\n  failed_at TIMESTAMP NOT NULL,\n  retried_count INTEGER DEFAULT 0,\n  resolved BOOLEAN DEFAULT false,\n  INDEX idx_notification (notification_id),\n  INDEX idx_failed (failed_at) WHERE NOT resolved\n);\n\n-- Cleanup function for expired notifications\nCREATE OR REPLACE FUNCTION cleanup_expired_notifications()\nRETURNS INTEGER AS $$\nDECLARE\n  deleted_count INTEGER;\nBEGIN\n  DELETE FROM notifications \n  WHERE expires_at IS NOT NULL AND expires_at < NOW();\n  GET DIAGNOSTICS deleted_count = ROW_COUNT;\n  RETURN deleted_count;\nEND;\n$$ LANGUAGE plpgsql;\n```\n\n### 6. Enhanced Client SDK\n\n```typescript\n// client-sdk.ts\nexport interface NotificationClientConfig {\n  url: string;\n  token: string;\n  maxReconnectAttempts?: number;\n  reconnectDelay?: number;\n  heartbeatInterval?: number;\n  autoReconnect?: boolean;\n  enableOrdering?: boolean;\n  forceReconnect?: boolean; // Force disconnect of oldest connection if limit exceeded\n}\n\nexport class NotificationClient {\n  private ws: WebSocket | null = null;\n  private url: string;\n  private token: string;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts: number;\n  private reconnectDelay: number;\n  private heartbeatInterval: number;\n  private autoReconnect: boolean;\n  private enableOrdering: boolean;\n  private forceReconnect: boolean;\n  private listeners: Map<string, Set<Function>> = new Map();\n  private heartbeatTimer: any = null;\n  private connectionId: string | null = null;\n  private lastSeenSequence: number = 0;\n  private pendingAcknowledgments: Set<string> = new Set();\n  private ackBatchTimer: any = null;\n\n  constructor(config: NotificationClientConfig) {\n    this.url = config.url;\n    this.token = config.token;\n    this.maxReconnectAttempts = config.maxReconnectAttempts ?? 5;\n    this.reconnectDelay = config.reconnectDelay ?? 1000;\n    this.heartbeatInterval = config.heartbeatInterval ?? 30000;\n    this.autoReconnect = config.autoReconnect ?? true;\n    this.enableOrdering = config.enableOrdering ?? false;\n    this.forceReconnect = config.forceReconnect ?? false;\n  }\n\n  connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const wsUrl = `${this.url}?token=${encodeURIComponent(this.token)}`;\n      this.ws = new WebSocket(wsUrl);\n\n      // Add force reconnect header if enabled\n      if (this.forceReconnect && this.reconnectAttempts > 0) {\n        // Note: WebSocket API doesn't support custom headers directly\n        // This would need to be implemented via query parameter or initial handshake\n      }\n\n      const connectTimeout = setTimeout(() => {\n        if (this.ws?.readyState !== WebSocket.OPEN) {\n          this.ws?.close();\n          reject(new Error('Connection timeout'));\n        }\n      }, 10000);\n\n      this.ws.onopen = () => {\n        clearTimeout(connectTimeout);\n        console.log('Connected to notification service');\n        this.reconnectAttempts = 0;\n        this.startHeartbeat();\n        resolve();\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          this.handleMessage(event.data);\n        } catch (error) {\n          console.error('Error handling message:', error);\n        }\n      };\n\n      this.ws.onerror = (error) => {\n        clearTimeout(connectTimeout);\n        console.error('WebSocket error:', error);\n        this.emit('error', error);\n      };\n\n      this.ws.onclose = (event) => {\n        clearTimeout(connectTimeout);\n        this.stopHeartbeat();\n        this.flushAcknowledgments(); // Send pending acks before disconnect\n        \n        console.log(`Disconnected from notification service (code: ${event.code})`);\n        this.emit('disconnected', { code: event.code, reason: event.reason });\n        \n        if (this.autoReconnect && event.code !== 1000) {\n          this.handleReconnect();\n        }\n      };\n    });\n  }\n\n  private handleMessage(data: string): void {\n    const message = JSON.parse(data);\n    \n    switch (message.type) {\n      case 'connected':\n        this.connectionId = message.connectionId;\n        this.lastSeenSequence = message.lastSeenSequence || 0;\n        this.emit('connected', message);\n        break;\n\n      case 'notification':\n        // Update sequence if ordering enabled\n        if (this.enableOrdering && message.sequence) {\n          this.lastSeenSequence = Math.max(this.lastSeenSequence, message.sequence);\n        }\n        \n        this.emit('notification', message.payload);\n        \n        // Auto-acknowledge with batching\n        if (message.payload.id) {\n          this.queueAcknowledgment(message.payload.id);\n        }\n        break;\n\n      case 'missed_notifications_complete':\n        this.emit('missed_notifications_complete', message);\n        break;\n\n      case 'pong':\n        this.emit('pong', message);\n        break;\n\n      case 'server_shutdown':\n        this.emit('server_shutdown', message);\n        break;\n\n      case 'force_disconnect':\n        this.emit('force_disconnect', message);\n        break;\n\n      case 'error':\n        this.emit('error', message);\n        break;\n\n      default:\n        this.emit(message.type, message);\n    }\n    \n    this.emit('message', message);\n  }\n\n  private handleReconnect(): void {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.error('Max reconnection attempts reached');\n      this.emit('max_reconnect', {});\n      return;\n    }\n\n    this.reconnectAttempts++;\n    const delay = Math.min(\n      this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1),\n      30000\n    );\n    \n    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);\n    this.emit('reconnecting', { attempt: this.reconnectAttempts, delay });\n    \n    setTimeout(() => {\n      this.connect().catch(err => {\n        console.error('Reconnection failed:', err);\n      });\n    }, delay);\n  }\n\n  private startHeartbeat(): void {\n    this.heartbeatTimer = setInterval(() => {\n      this.ping();\n    }, this.heartbeatInterval);\n  }\n\n  private stopHeartbeat(): void {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n  }\n\n  ping(): void {\n    this.send({ type: 'ping', timestamp: Date.now() });\n  }\n\n  on(event: string, callback: Function): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(callback);\n  }\n\n  off(event: string, callback: Function): void {\n    const callbacks = this.listeners.get(event);\n    if (callbacks) {\n      callbacks.delete(callback);\n    }\n  }\n\n  private emit(event: string, data: any): void {\n    const callbacks = this.listeners.get(event);\n    if (callbacks) {\n      callbacks.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in ${event} handler:`, error);\n        }\n      });\n    }\n  }\n\n  subscribe(channels: string[]): void {\n    if (!Array.isArray(channels) || channels.length === 0) {\n      throw new Error('channels must be a non-empty array');\n    }\n    this.send({ type: 'subscribe', channels });\n  }\n\n  unsubscribe(channels: string[]): void {\n    if (!Array.isArray(channels) || channels.length === 0) {\n      throw new Error('channels must be a non-empty array');\n    }\n    this.send({ type: 'unsubscribe', channels });\n  }\n\n  acknowledge(notificationId: string): void {\n    this.send({ type: 'ack', notificationId });\n  }\n\n  // NEW: Batched acknowledgment for efficiency\n  private queueAcknowledgment(notificationId: string): void {\n    this.pendingAcknowledgments.add(notificationId);\n    \n    // Clear existing timer\n    if (this.ackBatchTimer) {\n      clearTimeout(this.ackBatchTimer);\n    }\n    \n    // Batch acks together (send after 1 second or 10 acks, whichever comes first)\n    if (this.pendingAcknowledgments.size >= 10) {\n      this.flushAcknowledgments();\n    } else {\n      this.ackBatchTimer = setTimeout(() => {\n        this.flushAcknowledgments();\n      }, 1000);\n    }\n  }\n\n  private flushAcknowledgments(): void {\n    if (this.pendingAcknowledgments.size === 0) return;\n    \n    const ids = Array.from(this.pendingAcknowledgments);\n    this.pendingAcknowledgments.clear();\n    \n    if (this.ackBatchTimer) {\n      clearTimeout(this.ackBatchTimer);\n      this.ackBatchTimer = null;\n    }\n    \n    if (ids.length === 1) {\n      this.send({ type: 'ack', notificationId: ids[0] });\n    } else {\n      this.send({ type: 'ack_batch', notificationIds: ids });\n    }\n  }\n\n  // NEW: Request missed notifications explicitly\n  requestMissedNotifications(fromSequence?: number, limit?: number): void {\n    this.send({ \n      type: 'request_missed',\n      fromSequence: fromSequence ?? this.lastSeenSequence,\n      limit: limit ?? 50\n    });\n  }\n\n  private send(message: any): void {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      throw new Error('Not connected');\n    }\n    this.ws.send(JSON.stringify(message));\n  }\n\n  disconnect(): void {\n    this.autoReconnect = false;\n    this.stopHeartbeat();\n    this.flushAcknowledgments(); // Send any pending acks\n    \n    if (this.ws) {\n      this.ws.close(1000, 'Client disconnect');\n      this.ws = null;\n    }\n  }\n\n  isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n\n  getConnectionId(): string | null {\n    return this.connectionId;\n  }\n\n  getLastSeenSequence(): number {\n    return this.lastSeenSequence;\n  }\n}\n```"
}