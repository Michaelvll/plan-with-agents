{
  "initial_prompt": "Design a REST API for a todo list application with user authentication",
  "status": "debating",
  "rounds": 2,
  "started_at": "2026-01-17T08:37:36.973134",
  "ended_at": "2026-01-17T08:44:10.301846",
  "final_design": "## Design\n\n# Todo List REST API with User Authentication\n\n## Architecture Overview\n\nThe API follows a three-tier architecture with clear separation of concerns:\n- **Presentation Layer**: REST API endpoints (JSON)\n- **Business Logic Layer**: Authentication, authorization, todo management, and business rules\n- **Data Layer**: PostgreSQL database with normalized schema\n\n## Technology Stack\n\n- **Framework**: Node.js with Express.js\n- **Database**: PostgreSQL 14+ with connection pooling\n- **Authentication**: JWT (JSON Web Tokens) with bcrypt for password hashing\n- **Validation**: Joi or Zod for schema validation\n- **Rate Limiting**: express-rate-limit with Redis store\n- **Caching**: Redis (optional, graceful degradation)\n- **Logging**: Pino for structured logging\n- **API Documentation**: OpenAPI 3.0 specification\n- **Email**: Nodemailer with template support\n\n## Data Models\n\n### User Entity\n```sql\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  email VARCHAR(255) UNIQUE NOT NULL,\n  password_hash VARCHAR(255) NOT NULL,\n  email_verified BOOLEAN DEFAULT FALSE,\n  verification_token VARCHAR(255),\n  verification_token_expires_at TIMESTAMP,\n  is_active BOOLEAN DEFAULT TRUE,\n  failed_login_attempts INT DEFAULT 0,\n  locked_until TIMESTAMP,\n  password_changed_at TIMESTAMP,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  last_login_at TIMESTAMP\n);\n\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_users_is_active ON users(is_active);\nCREATE INDEX idx_users_verification_token ON users(verification_token) WHERE verification_token IS NOT NULL;\n```\n\n### Password History Entity\n```sql\nCREATE TABLE password_history (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  password_hash VARCHAR(255) NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_password_history_user_id ON password_history(user_id);\n```\n\n### Todo Entity\n```sql\nCREATE TABLE todos (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  title VARCHAR(255) NOT NULL,\n  description TEXT,\n  completed BOOLEAN DEFAULT FALSE,\n  priority VARCHAR(20) CHECK (priority IN ('low', 'medium', 'high')) DEFAULT 'medium',\n  due_date TIMESTAMP,\n  completed_at TIMESTAMP,\n  deleted_at TIMESTAMP,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_todos_user_id ON todos(user_id);\nCREATE INDEX idx_todos_user_completed ON todos(user_id, completed) WHERE deleted_at IS NULL;\nCREATE INDEX idx_todos_user_due_date ON todos(user_id, due_date) WHERE deleted_at IS NULL AND completed = FALSE;\nCREATE INDEX idx_todos_deleted_at ON todos(deleted_at) WHERE deleted_at IS NOT NULL;\n```\n\n### Refresh Token Entity\n```sql\nCREATE TABLE refresh_tokens (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n  token_hash VARCHAR(255) NOT NULL UNIQUE,\n  expires_at TIMESTAMP NOT NULL,\n  revoked_at TIMESTAMP,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);\nCREATE INDEX idx_refresh_tokens_token_hash ON refresh_tokens(token_hash);\nCREATE INDEX idx_refresh_tokens_expires_at ON refresh_tokens(expires_at) WHERE revoked_at IS NULL;\n```\n\n## API Endpoints\n\n### Health Check\n\n#### GET /api/v1/health\nCheck API health status (no authentication required).\n\n**Response (200):**\n```json\n{\n  \"status\": \"healthy\",\n  \"timestamp\": \"2026-01-17T10:00:00Z\",\n  \"version\": \"1.0.0\",\n  \"services\": {\n    \"database\": \"healthy\",\n    \"redis\": \"healthy\"\n  }\n}\n```\n\n### Authentication Endpoints\n\n#### POST /api/v1/auth/register\nRegister a new user and send verification email.\n\n**Request:**\n```json\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"SecurePass123!\"\n}\n```\n\n**Response (201):**\n```json\n{\n  \"userId\": \"uuid\",\n  \"email\": \"user@example.com\",\n  \"emailVerified\": false,\n  \"message\": \"Registration successful. Please check your email to verify your account.\"\n}\n```\n\n**Errors:**\n- 400: Validation error (invalid email, weak password)\n- 409: Email already exists\n- 429: Too many registration attempts\n\n**Notes:**\n- User receives email with verification link valid for 24 hours\n- Account is created but email_verified=false\n- User can login but certain features may be restricted\n\n#### POST /api/v1/auth/verify-email\nVerify email address using token from email.\n\n**Request:**\n```json\n{\n  \"token\": \"verification-token-from-email\"\n}\n```\n\n**Response (200):**\n```json\n{\n  \"message\": \"Email verified successfully\",\n  \"accessToken\": \"jwt-access-token\",\n  \"refreshToken\": \"jwt-refresh-token\",\n  \"expiresIn\": 900\n}\n```\n\n**Errors:**\n- 400: Invalid or expired token\n- 404: Token not found\n\n#### POST /api/v1/auth/resend-verification\nResend verification email.\n\n**Request:**\n```json\n{\n  \"email\": \"user@example.com\"\n}\n```\n\n**Response (200):**\n```json\n{\n  \"message\": \"Verification email sent\"\n}\n```\n\n**Errors:**\n- 400: Email already verified\n- 404: User not found\n- 429: Too many resend attempts\n\n#### POST /api/v1/auth/login\nAuthenticate user and receive JWT tokens.\n\n**Request:**\n```json\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"SecurePass123!\"\n}\n```\n\n**Response (200):**\n```json\n{\n  \"userId\": \"uuid\",\n  \"email\": \"user@example.com\",\n  \"emailVerified\": true,\n  \"accessToken\": \"jwt-access-token\",\n  \"refreshToken\": \"jwt-refresh-token\",\n  \"expiresIn\": 900\n}\n```\n\n**Errors:**\n- 401: Invalid credentials\n- 403: Account locked due to too many failed attempts\n- 423: Account is inactive\n- 400: Validation error\n- 429: Too many login attempts\n\n**Notes:**\n- Failed attempts increment counter\n- Account locks for 30 minutes after 5 failed attempts\n- Successful login resets failed_login_attempts to 0\n\n#### POST /api/v1/auth/refresh\nRefresh access token using refresh token.\n\n**Request:**\n```json\n{\n  \"refreshToken\": \"jwt-refresh-token\"\n}\n```\n\n**Response (200):**\n```json\n{\n  \"accessToken\": \"new-jwt-access-token\",\n  \"refreshToken\": \"new-jwt-refresh-token\",\n  \"expiresIn\": 900\n}\n```\n\n**Errors:**\n- 401: Invalid, expired, or revoked refresh token\n- 429: Too many refresh attempts\n\n**Notes:**\n- Old refresh token is revoked upon successful refresh\n- Implements token rotation for enhanced security\n\n#### POST /api/v1/auth/logout\nRevoke refresh token.\n\n**Headers:**\n```\nAuthorization: Bearer <jwt-access-token>\n```\n\n**Request:**\n```json\n{\n  \"refreshToken\": \"jwt-refresh-token\"\n}\n```\n\n**Response (204):**\nNo content.\n\n**Errors:**\n- 401: Unauthorized\n\n#### POST /api/v1/auth/change-password\nChange user password (requires current password).\n\n**Headers:**\n```\nAuthorization: Bearer <jwt-access-token>\n```\n\n**Request:**\n```json\n{\n  \"currentPassword\": \"SecurePass123!\",\n  \"newPassword\": \"NewSecurePass456!\"\n}\n```\n\n**Response (200):**\n```json\n{\n  \"message\": \"Password changed successfully\"\n}\n```\n\n**Errors:**\n- 401: Current password incorrect or unauthorized\n- 400: Validation error (weak password, same as old password, matches recent password history)\n\n**Notes:**\n- Checks against last 5 passwords in history\n- Revokes all refresh tokens for the user (forces re-login on all devices)\n- Updates password_changed_at timestamp\n\n#### POST /api/v1/auth/forgot-password\nRequest password reset email.\n\n**Request:**\n```json\n{\n  \"email\": \"user@example.com\"\n}\n```\n\n**Response (200):**\n```json\n{\n  \"message\": \"If an account exists with this email, a password reset link has been sent\"\n}\n```\n\n**Errors:**\n- 429: Too many reset attempts\n\n**Notes:**\n- Always returns 200 even if email not found (security best practice)\n- Reset token valid for 1 hour\n- Invalidates previous reset tokens\n\n#### POST /api/v1/auth/reset-password\nReset password using token from email.\n\n**Request:**\n```json\n{\n  \"token\": \"reset-token-from-email\",\n  \"newPassword\": \"NewSecurePass456!\"\n}\n```\n\n**Response (200):**\n```json\n{\n  \"message\": \"Password reset successfully\"\n}\n```\n\n**Errors:**\n- 400: Invalid or expired token, or validation error\n- 404: Token not found\n\n### Todo Endpoints\n\nAll todo endpoints require authentication via `Authorization: Bearer <jwt-access-token>` header.\n\n#### GET /api/v1/todos\nRetrieve all todos for authenticated user (excludes soft-deleted by default).\n\n**Query Parameters:**\n- `completed` (optional): boolean - filter by completion status\n- `priority` (optional): low|medium|high - filter by priority\n- `includeDeleted` (optional): boolean - include soft-deleted todos (default: false)\n- `sortBy` (optional): created_at|due_date|priority|updated_at|title - sort field (default: created_at)\n- `order` (optional): asc|desc - sort order (default: desc)\n- `page` (optional): integer - page number (default: 1, min: 1)\n- `limit` (optional): integer - items per page (default: 20, min: 1, max: 100)\n- `search` (optional): string - search in title and description (min 2 chars)\n\n**Response (200):**\n```json\n{\n  \"todos\": [\n    {\n      \"id\": \"uuid\",\n      \"title\": \"Complete project\",\n      \"description\": \"Finish the REST API design\",\n      \"completed\": false,\n      \"priority\": \"high\",\n      \"dueDate\": \"2026-01-20T00:00:00Z\",\n      \"completedAt\": null,\n      \"createdAt\": \"2026-01-17T10:00:00Z\",\n      \"updatedAt\": \"2026-01-17T10:00:00Z\"\n    }\n  ],\n  \"pagination\": {\n    \"page\": 1,\n    \"limit\": 20,\n    \"total\": 45,\n    \"totalPages\": 3,\n    \"hasNext\": true,\n    \"hasPrevious\": false\n  }\n}\n```\n\n**Errors:**\n- 401: Unauthorized (invalid or expired token)\n- 400: Invalid query parameters\n\n#### GET /api/v1/todos/:id\nRetrieve a specific todo.\n\n**Response (200):**\n```json\n{\n  \"id\": \"uuid\",\n  \"title\": \"Complete project\",\n  \"description\": \"Finish the REST API design\",\n  \"completed\": false,\n  \"priority\": \"high\",\n  \"dueDate\": \"2026-01-20T00:00:00Z\",\n  \"completedAt\": null,\n  \"createdAt\": \"2026-01-17T10:00:00Z\",\n  \"updatedAt\": \"2026-01-17T10:00:00Z\"\n}\n```\n\n**Errors:**\n- 401: Unauthorized\n- 404: Todo not found or deleted\n- 403: Todo belongs to another user\n\n#### POST /api/v1/todos\nCreate a new todo.\n\n**Request:**\n```json\n{\n  \"title\": \"Complete project\",\n  \"description\": \"Finish the REST API design\",\n  \"priority\": \"high\",\n  \"dueDate\": \"2026-01-20T00:00:00Z\"\n}\n```\n\n**Response (201):**\n```json\n{\n  \"id\": \"uuid\",\n  \"title\": \"Complete project\",\n  \"description\": \"Finish the REST API design\",\n  \"completed\": false,\n  \"priority\": \"high\",\n  \"dueDate\": \"2026-01-20T00:00:00Z\",\n  \"completedAt\": null,\n  \"createdAt\": \"2026-01-17T10:00:00Z\",\n  \"updatedAt\": \"2026-01-17T10:00:00Z\"\n}\n```\n\n**Errors:**\n- 401: Unauthorized\n- 400: Validation error (missing title, invalid priority, title too long)\n- 422: Due date is in the past\n\n#### PUT /api/v1/todos/:id\nUpdate an existing todo (full replacement).\n\n**Request:**\n```json\n{\n  \"title\": \"Complete project - Updated\",\n  \"description\": \"Finish the REST API design with documentation\",\n  \"completed\": true,\n  \"priority\": \"medium\",\n  \"dueDate\": \"2026-01-21T00:00:00Z\"\n}\n```\n\n**Response (200):**\n```json\n{\n  \"id\": \"uuid\",\n  \"title\": \"Complete project - Updated\",\n  \"description\": \"Finish the REST API design with documentation\",\n  \"completed\": true,\n  \"priority\": \"medium\",\n  \"dueDate\": \"2026-01-21T00:00:00Z\",\n  \"completedAt\": \"2026-01-17T12:00:00Z\",\n  \"createdAt\": \"2026-01-17T10:00:00Z\",\n  \"updatedAt\": \"2026-01-17T12:00:00Z\"\n}\n```\n\n**Errors:**\n- 401: Unauthorized\n- 404: Todo not found\n- 403: Todo belongs to another user\n- 400: Validation error\n- 422: Due date is in the past\n\n**Notes:**\n- When completed changes from false to true, sets completedAt to current timestamp\n- When completed changes from true to false, sets completedAt to null\n\n#### PATCH /api/v1/todos/:id\nPartially update a todo.\n\n**Request:**\n```json\n{\n  \"completed\": true\n}\n```\n\n**Response (200):**\n```json\n{\n  \"id\": \"uuid\",\n  \"title\": \"Complete project\",\n  \"description\": \"Finish the REST API design\",\n  \"completed\": true,\n  \"priority\": \"high\",\n  \"dueDate\": \"2026-01-20T00:00:00Z\",\n  \"completedAt\": \"2026-01-17T12:00:00Z\",\n  \"createdAt\": \"2026-01-17T10:00:00Z\",\n  \"updatedAt\": \"2026-01-17T12:00:00Z\"\n}\n```\n\n**Errors:**\n- 401: Unauthorized\n- 404: Todo not found\n- 403: Todo belongs to another user\n- 400: Validation error\n\n#### DELETE /api/v1/todos/:id\nSoft delete a todo (sets deleted_at timestamp).\n\n**Query Parameters:**\n- `permanent` (optional): boolean - permanently delete (default: false)\n\n**Response (204):**\nNo content.\n\n**Errors:**\n- 401: Unauthorized\n- 404: Todo not found\n- 403: Todo belongs to another user\n\n**Notes:**\n- Default behavior is soft delete (sets deleted_at)\n- Permanent delete only works if user has already soft-deleted the item\n- This prevents accidental permanent deletion\n\n#### POST /api/v1/todos/:id/restore\nRestore a soft-deleted todo.\n\n**Response (200):**\n```json\n{\n  \"id\": \"uuid\",\n  \"title\": \"Complete project\",\n  \"description\": \"Finish the REST API design\",\n  \"completed\": false,\n  \"priority\": \"high\",\n  \"dueDate\": \"2026-01-20T00:00:00Z\",\n  \"completedAt\": null,\n  \"createdAt\": \"2026-01-17T10:00:00Z\",\n  \"updatedAt\": \"2026-01-17T12:00:00Z\"\n}\n```\n\n**Errors:**\n- 401: Unauthorized\n- 404: Todo not found or not deleted\n- 403: Todo belongs to another user\n\n#### GET /api/v1/todos/stats\nGet todo statistics for the authenticated user.\n\n**Response (200):**\n```json\n{\n  \"total\": 100,\n  \"completed\": 45,\n  \"pending\": 55,\n  \"overdue\": 10,\n  \"dueToday\": 5,\n  \"dueThisWeek\": 15,\n  \"byPriority\": {\n    \"low\": 30,\n    \"medium\": 50,\n    \"high\": 20\n  },\n  \"completionRate\": 0.45\n}\n```\n\n**Errors:**\n- 401: Unauthorized\n\n**Notes:**\n- Stats exclude soft-deleted todos\n- Results cached for 2 minutes if Redis is available\n- Overdue count only includes incomplete todos past due date\n\n## Security Implementation\n\n### Password Requirements\n- Minimum 12 characters\n- At least one uppercase letter\n- At least one lowercase letter\n- At least one number\n- At least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)\n- Cannot match last 5 passwords\n- Cannot contain user's email local part\n\n### Password Hashing\n- Use bcrypt with salt rounds of 12\n- Store password hash only, never plain text\n- Maintain password_history table to prevent reuse\n\n### JWT Configuration\n- **Access tokens**: 15 minute expiration\n- **Refresh tokens**: 7 day expiration with rotation\n- **Algorithm**: RS256 (asymmetric)\n- **Access token payload**: { userId, email, iat, exp, jti }\n- **Refresh token payload**: { userId, tokenId, iat, exp, jti }\n- Implement token revocation via refresh_tokens table\n- Generate new key pair on application bootstrap if not exists\n\n### Account Security\n- Lock account after 5 failed login attempts\n- Automatic unlock after 30 minutes\n- Track last_login_at timestamp\n- Email notifications for:\n  - Successful login from new IP (optional feature)\n  - Password change\n  - Account lock event\n  - Email verification\n  - Password reset\n\n### Email Verification\n- Required for full account access\n- Unverified users can login but with limited capabilities\n- Verification token expires after 24 hours\n- Token is random 32-byte hex string\n- Can resend verification email (rate limited: max 3 per hour)\n\n### Rate Limiting\n\nPer-IP limits (unauthenticated):\n- POST /api/v1/auth/register: 3 per hour\n- POST /api/v1/auth/login: 10 per 15 minutes\n- POST /api/v1/auth/forgot-password: 3 per hour\n- POST /api/v1/auth/reset-password: 5 per hour\n- POST /api/v1/auth/verify-email: 10 per hour\n- POST /api/v1/auth/resend-verification: 3 per hour\n\nPer-user limits (authenticated):\n- POST /api/v1/auth/refresh: 20 per hour\n- POST /api/v1/auth/change-password: 5 per hour\n- Todo endpoints: 300 per 15 minutes\n- GET /api/v1/todos/stats: 100 per 15 minutes\n\nGlobal limits:\n- All GET endpoints: 1000 per 15 minutes per IP\n- Health check: No limit\n\nReturn 429 with `Retry-After` header.\n\n### Input Validation\n- Email: RFC 5322 compliant, max 255 chars\n- Title: 1-255 characters, required\n- Description: 0-5000 characters, optional\n- Priority: enum (low, medium, high)\n- Due date: ISO 8601 format, must be future date for new todos\n- Passwords: validated against requirements above\n- UUIDs: valid v4 format\n- Sanitize inputs to prevent XSS (strip HTML tags)\n- Use parameterized queries (prevents SQL injection)\n\n### CORS Configuration\n- Production: Whitelist specific origins from environment variable\n- Development: Allow localhost with credentials\n- Allowed methods: GET, POST, PUT, PATCH, DELETE, OPTIONS\n- Allowed headers: Content-Type, Authorization\n- Expose headers: X-API-Version, X-Request-ID\n- Max age: 86400 (24 hours)\n- Credentials: true\n\n### Security Headers (Helmet)\n```javascript\n{\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  noSniff: true,\n  frameguard: { action: 'deny' },\n  xssFilter: true\n}\n```\n\n## Error Response Format\n\nAll errors follow this consistent structure:\n\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Request validation failed\",\n    \"details\": [\n      {\n        \"field\": \"email\",\n        \"message\": \"Email is already registered\",\n        \"code\": \"DUPLICATE_EMAIL\"\n      }\n    ],\n    \"timestamp\": \"2026-01-17T10:00:00Z\",\n    \"path\": \"/api/v1/auth/register\",\n    \"requestId\": \"uuid\"\n  }\n}\n```\n\n### Standard Error Codes\n- `VALIDATION_ERROR`: Input validation failed\n- `AUTHENTICATION_ERROR`: Authentication failed\n- `AUTHORIZATION_ERROR`: Insufficient permissions\n- `RESOURCE_NOT_FOUND`: Requested resource doesn't exist\n- `DUPLICATE_RESOURCE`: Resource already exists (email, etc.)\n- `RATE_LIMIT_EXCEEDED`: Too many requests\n- `INTERNAL_ERROR`: Server error (never expose internal details)\n- `ACCOUNT_LOCKED`: Account locked due to failed attempts\n- `ACCOUNT_INACTIVE`: Account is deactivated\n- `EMAIL_NOT_VERIFIED`: Email verification required for this action\n- `TOKEN_EXPIRED`: JWT or verification token expired\n- `TOKEN_INVALID`: Malformed or invalid token\n\n## HTTP Status Codes\n\n- 200: Success\n- 201: Created\n- 204: No Content\n- 400: Bad Request (validation errors)\n- 401: Unauthorized (missing or invalid token)\n- 403: Forbidden (insufficient permissions, email not verified)\n- 404: Not Found\n- 409: Conflict (duplicate resource)\n- 422: Unprocessable Entity (semantic errors)\n- 423: Locked (account locked)\n- 429: Too Many Requests\n- 500: Internal Server Error\n- 503: Service Unavailable\n\n## Middleware Stack (Execution Order)\n\n1. **Request ID**: Generate UUID for request tracing\n2. **Structured Logging**: Log request start with context\n3. **CORS**: Configure allowed origins and credentials\n4. **Helmet**: Apply security headers\n5. **Body Parser**: JSON parsing with 10kb limit\n6. **Rate Limiter**: IP and user-based rate limiting with Redis backend\n7. **Request Validator**: Schema validation and sanitization\n8. **Authentication**: JWT verification for protected routes\n9. **Email Verification Check**: Enforce email verification for sensitive operations\n10. **Route Handlers**: Business logic\n11. **Error Handler**: Centralized error processing (must be last)\n\n## Database Connection Management\n\n```javascript\n{\n  pool: {\n    min: 2,\n    max: 20,\n    acquireTimeoutMillis: 30000,\n    idleTimeoutMillis: 30000\n  },\n  connectionTimeoutMillis: 5000,\n  statementTimeout: 10000,\n  queryTimeout: 10000,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: true } : false\n}\n```\n\n- Implement circuit breaker pattern with 50% failure threshold\n- Exponential backoff for reconnection: 1s, 2s, 4s, 8s, max 30s\n- Health check query every 30 seconds: `SELECT 1`\n- Use transactions for multi-query operations\n- Implement query timeout monitoring and alerting\n\n## Observability\n\n### Logging Strategy\n```javascript\n{\n  level: process.env.LOG_LEVEL || 'info',\n  formatters: {\n    level: (label) => ({ level: label }),\n    bindings: (bindings) => ({ \n      pid: bindings.pid, \n      hostname: bindings.hostname,\n      nodeVersion: process.version\n    })\n  },\n  redact: ['password', 'token', 'accessToken', 'refreshToken', 'authorization'],\n  serializers: {\n    req: (req) => ({\n      id: req.id,\n      method: req.method,\n      url: req.url,\n      query: req.query,\n      params: req.params,\n      remoteAddress: req.ip\n    }),\n    res: (res) => ({\n      statusCode: res.statusCode\n    }),\n    err: pino.stdSerializers.err\n  }\n}\n```\n\n**Log Events:**\n- All HTTP requests (method, path, status, duration, requestId)\n- Authentication events (login, logout, token refresh, failures)\n- Failed login attempts with IP address\n- Account lock/unlock events\n- Email verification events\n- Password changes\n- Database query errors\n- Rate limit violations\n- Unhandled errors with stack traces\n\n### Metrics Collection\n\n- `http_request_duration_seconds`: Histogram by method, route, status\n- `http_requests_total`: Counter by method, route, status\n- `auth_attempts_total`: Counter by result (success, failure, locked)\n- `db_query_duration_seconds`: Histogram by query type\n- `db_pool_connections`: Gauge (active, idle, total)\n- `cache_hits_total`: Counter by cache key type\n- `cache_misses_total`: Counter by cache key type\n- `rate_limit_exceeded_total`: Counter by endpoint\n- `tokens_issued_total`: Counter by type (access, refresh)\n- `tokens_revoked_total`: Counter\n\n### Health Monitoring\n\n**Endpoints for monitoring:**\n- GET /api/v1/health: Basic health check\n- GET /api/v1/health/ready: Readiness probe (checks DB, Redis)\n- GET /api/v1/health/live: Liveness probe (app responsive)\n\n**Alerts:**\n- Error rate > 5% for 5 minutes\n- P95 response time > 1 second\n- Database connection pool exhaustion\n- Redis connection failures\n- Failed login rate > 50 per minute (potential attack)\n- Disk space < 10%\n\n## Caching Strategy\n\nRedis is **optional** for this API. The system degrades gracefully without Redis:\n\n**With Redis:**\n- Rate limiting counters (required for accurate rate limiting)\n- User stats cache: 2 minute TTL\n- User profile cache: 5 minute TTL\n- Email verification rate limit counters\n\n**Without Redis:**\n- Rate limiting falls back to in-memory (per-instance, less accurate)\n- Stats and profiles are computed on every request (slower but functional)\n- Application remains fully functional\n\n**Cache Keys:**\n```\nuser:profile:{userId}\nuser:stats:{userId}\nratelimit:{endpoint}:{identifier}\n```\n\n**Cache Invalidation:**\n- User profile: invalidate on password change, email verification\n- User stats: invalidate on todo create, update, delete, complete\n- Use Redis EXPIRE for TTL-based expiration\n- Implement cache warming for frequently accessed user stats\n\n**Fallback Strategy:**\n```javascript\nasync function getCachedOrFetch(key, fetchFn, ttl) {\n  if (!redisClient || !redisClient.isReady) {\n    return await fetchFn();\n  }\n  \n  try {\n    const cached = await redisClient.get(key);\n    if (cached) return JSON.parse(cached);\n    \n    const data = await fetchFn();\n    await redisClient.setEx(key, ttl, JSON.stringify(data));\n    return data;\n  } catch (err) {\n    logger.warn({ err, key }, 'Cache error, falling back to direct fetch');\n    return await fetchFn();\n  }\n}\n```\n\n## Scalability Considerations\n\n### Horizontal Scaling\n- Stateless application design (all state in DB or Redis)\n- Load balancer with health check endpoint\n- Session-less authentication (JWT)\n- Shared Redis for rate limiting across instances\n- Database read replicas for GET endpoints\n\n### Database Optimization\n- Compound indexes for common query patterns:\n  - `(user_id, completed, deleted_at)` for todo listing\n  - `(user_id, due_date)` for overdue queries\n- Implement query result caching for stats endpoint\n- Use `EXPLAIN ANALYZE` to optimize slow queries\n- Consider partitioning todos table by user_id if dataset > 10M rows\n- Implement read replica routing for GET requests\n\n### Performance Targets\n- P95 response time < 200ms for todo CRUD\n- P95 response time < 500ms for stats endpoint\n- Support 1000 concurrent users per instance\n- Database connection pool should handle 20 concurrent requests\n\n## API Versioning\n\n- URL-based versioning: `/api/v1/`, `/api/v2/`\n- Response header: `X-API-Version: 1.0.0`\n- Maintain backward compatibility within major versions\n- Deprecation process:\n  1. Announce deprecation 6 months in advance\n  2. Add `Deprecated` header to responses\n  3. Log usage of deprecated endpoints\n  4. Provide migration guide in API docs\n  5. Remove in next major version\n\n## Deployment and Operations\n\n### Environment Variables\n```\nNODE_ENV=production\nPORT=3000\nDATABASE_URL=postgresql://user:pass@host:5432/dbname\nREDIS_URL=redis://host:6379\nJWT_PRIVATE_KEY_PATH=/secrets/jwt-private.pem\nJWT_PUBLIC_KEY_PATH=/secrets/jwt-public.pem\nCORS_ORIGINS=https://example.com,https://app.example.com\nEMAIL_SMTP_HOST=smtp.example.com\nEMAIL_SMTP_PORT=587\nEMAIL_FROM=noreply@example.com\nEMAIL_SMTP_USER=username\nEMAIL_SMTP_PASSWORD=password\nAPI_BASE_URL=https://api.example.com\nLOG_LEVEL=info\n```\n\n### Backup and Recovery\n- Automated daily PostgreSQL backups at 2 AM UTC\n- Point-in-time recovery enabled (WAL archiving)\n- Backup retention: 30 days for daily, 90 days for weekly\n- Test restoration monthly in staging environment\n- Document RTO (4 hours) and RPO (1 hour)\n\n### Monitoring and Alerting\n- Application performance monitoring (APM)\n- Error tracking with stack traces\n- Log aggregation and searching\n- Uptime monitoring from multiple regions\n- Database query performance monitoring"
}